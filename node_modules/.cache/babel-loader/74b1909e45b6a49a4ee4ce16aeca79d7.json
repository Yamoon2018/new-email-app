{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\n\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  } // usable characters that do not need encoding\n\n\n  var ranges = [// https://tools.ietf.org/html/rfc2045#section-6.7\n  [0x09], // <TAB>\n  [0x0a], // <LF>\n  [0x0d], // <CR>\n  [0x20, 0x3c], // <SP>!\"#$%&'()*+,-./0123456789:;\n  [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n  ];\n  var result = '';\n  var ord;\n\n  for (var i = 0, len = buffer.length; i < len; i++) {\n    ord = buffer[i]; // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line\n\n    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n      result += String.fromCharCode(ord);\n      continue;\n    }\n\n    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }\n\n  return result;\n}\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  var pos = 0;\n  var len = str.length;\n  var match, code, line;\n  var lineMargin = Math.floor(lineLength / 3);\n  var result = ''; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = str.substr(pos, lineLength);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.match(/[=][\\da-f]{0,2}$/i)) {\n      // push incomplete encoding sequences to the next line\n      if (match = line.match(/[=][\\da-f]{0,1}$/i)) {\n        line = line.substr(0, line.length - match[0].length);\n      } // ensure that utf-8 sequences are not split\n\n\n      while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\\da-f]{2}$/gi))) {\n        code = parseInt(match[0].substr(1, 2), 16);\n\n        if (code < 128) {\n          break;\n        }\n\n        line = line.substr(0, line.length - 3);\n\n        if (code >= 0xc0) {\n          break;\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === lineLength && line.match(/[=][\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === lineLength) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\n\n\nfunction checkRanges(nr, ranges) {\n  for (var i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n\n    if (ranges[i].length === 1 && nr === ranges[i][0]) {\n      return true;\n    }\n\n    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nvar Encoder = /*#__PURE__*/function (_Transform) {\n  _inherits(Encoder, _Transform);\n\n  var _super = _createSuper(Encoder);\n\n  function Encoder(options) {\n    var _this;\n\n    _classCallCheck(this, Encoder);\n\n    _this = _super.call(this); // init Transform\n\n    _this.options = options || {};\n\n    if (_this.options.lineLength !== false) {\n      _this.options.lineLength = _this.options.lineLength || 76;\n    }\n\n    _this._curLine = '';\n    _this.inputBytes = 0;\n    _this.outputBytes = 0;\n    return _this;\n  }\n\n  _createClass(Encoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      var _this2 = this;\n\n      var qp;\n\n      if (encoding !== 'buffer') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (!chunk || !chunk.length) {\n        return done();\n      }\n\n      this.inputBytes += chunk.length;\n\n      if (this.options.lineLength) {\n        qp = this._curLine + encode(chunk);\n        qp = wrap(qp, this.options.lineLength);\n        qp = qp.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n          _this2._curLine = lastLine;\n          return lineBreak;\n        });\n\n        if (qp) {\n          this.outputBytes += qp.length;\n          this.push(qp);\n        }\n      } else {\n        qp = encode(chunk);\n        this.outputBytes += qp.length;\n        this.push(qp, 'ascii');\n      }\n\n      done();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._curLine) {\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n      }\n\n      done();\n    }\n  }]);\n\n  return Encoder;\n}(Transform); // expose to the world\n\n\nmodule.exports = {\n  encode: encode,\n  wrap: wrap,\n  Encoder: Encoder\n};","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/qp/index.js"],"names":["Transform","require","encode","buffer","Buffer","from","ranges","result","ord","i","len","length","checkRanges","String","fromCharCode","toString","toUpperCase","wrap","str","lineLength","pos","match","code","line","lineMargin","Math","floor","substr","index","parseInt","nr","Encoder","options","_curLine","inputBytes","outputBytes","chunk","encoding","done","qp","replace","lineBreak","lastLine","push","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    let ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0a], // <LF>\n        [0x0d], // <CR>\n        [0x20, 0x3c], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    let result = '';\n    let ord;\n\n    for (let i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let pos = 0;\n    let len = str.length;\n    let match, code, line;\n    let lineMargin = Math.floor(lineLength / 3);\n    let result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.match(/[=][\\da-f]{0,2}$/i)) {\n            // push incomplete encoding sequences to the next line\n            if ((match = line.match(/[=][\\da-f]{0,1}$/i))) {\n                line = line.substr(0, line.length - match[0].length);\n            }\n\n            // ensure that utf-8 sequences are not split\n            while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\\da-f]{2}$/gi))) {\n                code = parseInt(match[0].substr(1, 2), 16);\n                if (code < 128) {\n                    break;\n                }\n\n                line = line.substr(0, line.length - 3);\n\n                if (code >= 0xc0) {\n                    break;\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/[=][\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (let i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        let qp;\n\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this.options.lineLength) {\n            qp = this._curLine + encode(chunk);\n            qp = wrap(qp, this.options.lineLength);\n            qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine) => {\n                this._curLine = lastLine;\n                return lineBreak;\n            });\n\n            if (qp) {\n                this.outputBytes += qp.length;\n                this.push(qp);\n            }\n        } else {\n            qp = encode(chunk);\n            this.outputBytes += qp.length;\n            this.push(qp, 'ascii');\n        }\n\n        done();\n    }\n\n    _flush(done) {\n        if (this._curLine) {\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n"]},"metadata":{},"sourceType":"script"}