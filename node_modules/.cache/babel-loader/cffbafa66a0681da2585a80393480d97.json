{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar types = require('ast-types');\n\nvar esprima = require('esprima');\n\nvar escodegen = require('escodegen');\n/**\n * Helper functions.\n */\n\n\nvar n = types.namedTypes;\nvar b = types.builders;\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator(jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n\n  var ast = esprima.parse(jsStr); // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n\n  names = names.slice(0); // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n\n  types.visit(ast, {\n    visitFunction: function visitFunction(path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true; // add function name to `names` array\n\n        names.push(path.node.id.name);\n      }\n\n      this.traverse(path);\n    }\n  }); // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n\n  types.visit(ast, {\n    visitCallExpression: function visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n  });\n  return escodegen.generate(ast);\n}\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames(node, names) {\n  var name;\n  var callee = node.callee;\n\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  } // now that we have the `name`, check if any entries match in the `names` array\n\n\n  var n;\n\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/degenerator/index.js"],"names":["types","require","esprima","escodegen","n","namedTypes","b","builders","module","exports","degenerator","jsStr","names","Array","isArray","TypeError","ast","parse","slice","visit","visitFunction","path","node","id","generator","push","name","traverse","visitCallExpression","checkNames","parent","delegate","expr","yieldExpression","generate","callee","type","object","property","raw","Error","i","length","test"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar types = require('ast-types');\nvar esprima = require('esprima');\nvar escodegen = require('escodegen');\n\n/**\n * Helper functions.\n */\n\nvar n = types.namedTypes;\nvar b = types.builders;\n\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator (jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n\n  var ast = esprima.parse(jsStr);\n\n  // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n  names = names.slice(0);\n\n\n  // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n  types.visit(ast, {\n    visitFunction: function(path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true;\n\n        // add function name to `names` array\n        names.push(path.node.id.name);\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n  types.visit(ast, {\n    visitCallExpression: function(path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  return escodegen.generate(ast);\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames (node, names) {\n  var name;\n  var callee = node.callee;\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  }\n\n  // now that we have the `name`, check if any entries match in the `names` array\n  var n;\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}