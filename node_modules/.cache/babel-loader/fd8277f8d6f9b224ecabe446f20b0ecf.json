{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar PoolResource = require('./pool-resource');\n\nvar SMTPConnection = require('../smtp-connection');\n\nvar wellKnown = require('../well-known');\n\nvar shared = require('../shared');\n\nvar packageData = require('../../package.json');\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\n\n\nvar SMTPPool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPPool, _EventEmitter);\n\n  var _super = _createSuper(SMTPPool);\n\n  function SMTPPool(options) {\n    var _this;\n\n    _classCallCheck(this, SMTPPool);\n\n    _this = _super.call(this);\n    options = options || {};\n\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n\n    var urlData;\n    var service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n      _this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n\n    _this.options = shared.assign(false, // create new object\n    options, // regular options\n    urlData, // url options\n    service && wellKnown(service) // wellknown options\n    );\n    _this.options.maxConnections = _this.options.maxConnections || 5;\n    _this.options.maxMessages = _this.options.maxMessages || 100;\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-pool'\n    }); // temporary object\n\n    var connection = new SMTPConnection(_this.options);\n    _this.name = 'SMTP (pool)';\n    _this.version = packageData.version + '[client:' + connection.version + ']';\n    _this._rateLimit = {\n      counter: 0,\n      timeout: null,\n      waiting: [],\n      checkpoint: false,\n      delta: Number(_this.options.rateDelta) || 1000,\n      limit: Number(_this.options.rateLimit) || 0\n    };\n    _this._closed = false;\n    _this._queue = [];\n    _this._connections = [];\n    _this._connectionCounter = 0;\n    _this.idling = true;\n    setImmediate(function () {\n      if (_this.idling) {\n        _this.emit('idle');\n      }\n    });\n    return _this;\n  }\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n\n\n  _createClass(SMTPPool, [{\n    key: \"getSocket\",\n    value: function getSocket(options, callback) {\n      // return immediatelly\n      return setImmediate(function () {\n        return callback(null, false);\n      });\n    }\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this2 = this;\n\n      if (this._closed) {\n        return false;\n      }\n\n      this._queue.push({\n        mail: mail,\n        requeueAttempts: 0,\n        callback: callback\n      });\n\n      if (this.idling && this._queue.length >= this.options.maxConnections) {\n        this.idling = false;\n      }\n\n      setImmediate(function () {\n        return _this2._processMessages();\n      });\n      return true;\n    }\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this3 = this;\n\n      var connection;\n      var len = this._connections.length;\n      this._closed = true; // clear rate limit timer if it exists\n\n      clearTimeout(this._rateLimit.timeout);\n\n      if (!len && !this._queue.length) {\n        return;\n      } // remove all available connections\n\n\n      for (var i = len - 1; i >= 0; i--) {\n        if (this._connections[i] && this._connections[i].available) {\n          connection = this._connections[i];\n          connection.close();\n          this.logger.info({\n            tnx: 'connection',\n            cid: connection.id,\n            action: 'removed'\n          }, 'Connection #%s removed', connection.id);\n        }\n      }\n\n      if (len && !this._connections.length) {\n        this.logger.debug({\n          tnx: 'connection'\n        }, 'All connections removed');\n      }\n\n      if (!this._queue.length) {\n        return;\n      } // make sure that entire queue would be cleaned\n\n\n      var invokeCallbacks = function invokeCallbacks() {\n        if (!_this3._queue.length) {\n          _this3.logger.debug({\n            tnx: 'connection'\n          }, 'Pending queue entries cleared');\n\n          return;\n        }\n\n        var entry = _this3._queue.shift();\n\n        if (entry && typeof entry.callback === 'function') {\n          try {\n            entry.callback(new Error('Connection pool was closed'));\n          } catch (E) {\n            _this3.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n        }\n\n        setImmediate(invokeCallbacks);\n      };\n\n      setImmediate(invokeCallbacks);\n    }\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function _processMessages() {\n      var _this4 = this;\n\n      var connection;\n      var i, len; // do nothing if already closed\n\n      if (this._closed) {\n        return;\n      } // do nothing if queue is empty\n\n\n      if (!this._queue.length) {\n        if (!this.idling) {\n          // no pending jobs\n          this.idling = true;\n          this.emit('idle');\n        }\n\n        return;\n      } // find first available connection\n\n\n      for (i = 0, len = this._connections.length; i < len; i++) {\n        if (this._connections[i].available) {\n          connection = this._connections[i];\n          break;\n        }\n      }\n\n      if (!connection && this._connections.length < this.options.maxConnections) {\n        connection = this._createConnection();\n      }\n\n      if (!connection) {\n        // no more free connection slots available\n        this.idling = false;\n        return;\n      } // check if there is free space in the processing queue\n\n\n      if (!this.idling && this._queue.length < this.options.maxConnections) {\n        this.idling = true;\n        this.emit('idle');\n      }\n\n      var entry = connection.queueEntry = this._queue.shift();\n\n      entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n      connection.available = false;\n      this.logger.debug({\n        tnx: 'pool',\n        cid: connection.id,\n        messageId: entry.messageId,\n        action: 'assign'\n      }, 'Assigned message <%s> to #%s (%s)', entry.messageId, connection.id, connection.messages + 1);\n\n      if (this._rateLimit.limit) {\n        this._rateLimit.counter++;\n\n        if (!this._rateLimit.checkpoint) {\n          this._rateLimit.checkpoint = Date.now();\n        }\n      }\n\n      connection.send(entry.mail, function (err, info) {\n        // only process callback if current handler is not changed\n        if (entry === connection.queueEntry) {\n          try {\n            entry.callback(err, info);\n          } catch (E) {\n            _this4.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n\n          connection.queueEntry = false;\n        }\n      });\n    }\n    /**\n     * Creates a new pool resource\n     */\n\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection() {\n      var _this5 = this;\n\n      var connection = new PoolResource(this);\n      connection.id = ++this._connectionCounter;\n      this.logger.info({\n        tnx: 'pool',\n        cid: connection.id,\n        action: 'conection'\n      }, 'Created new pool resource #%s', connection.id); // resource comes available\n\n      connection.on('available', function () {\n        _this5.logger.debug({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'available'\n        }, 'Connection #%s became available', connection.id);\n\n        if (_this5._closed) {\n          // if already closed run close() that will remove this connections from connections list\n          _this5.close();\n        } else {\n          // check if there's anything else to send\n          _this5._processMessages();\n        }\n      }); // resource is terminated with an error\n\n      connection.once('error', function (err) {\n        if (err.code !== 'EMAXLIMIT') {\n          _this5.logger.error({\n            err: err,\n            tnx: 'pool',\n            cid: connection.id\n          }, 'Pool Error for #%s: %s', connection.id, err.message);\n        } else {\n          _this5.logger.debug({\n            tnx: 'pool',\n            cid: connection.id,\n            action: 'maxlimit'\n          }, 'Max messages limit exchausted for #%s', connection.id);\n        }\n\n        if (connection.queueEntry) {\n          try {\n            connection.queueEntry.callback(err);\n          } catch (E) {\n            _this5.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n\n          connection.queueEntry = false;\n        } // remove the erroneus connection from connections list\n\n\n        _this5._removeConnection(connection);\n\n        _this5._continueProcessing();\n      });\n      connection.once('close', function () {\n        _this5.logger.info({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'closed'\n        }, 'Connection #%s was closed', connection.id);\n\n        _this5._removeConnection(connection);\n\n        if (connection.queueEntry) {\n          // If the connection closed when sending, add the message to the queue again\n          // if max number of requeues is not reached yet\n          // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n          // in the next event loop\n          setTimeout(function () {\n            if (connection.queueEntry) {\n              if (_this5._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                _this5._requeueEntryOnConnectionClose(connection);\n              } else {\n                _this5._failDeliveryOnConnectionClose(connection);\n              }\n            }\n\n            _this5._continueProcessing();\n          }, 50);\n        } else {\n          _this5._continueProcessing();\n        }\n      });\n\n      this._connections.push(connection);\n\n      return connection;\n    }\n  }, {\n    key: \"_shouldRequeuOnConnectionClose\",\n    value: function _shouldRequeuOnConnectionClose(queueEntry) {\n      if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n        return true;\n      }\n\n      return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n  }, {\n    key: \"_failDeliveryOnConnectionClose\",\n    value: function _failDeliveryOnConnectionClose(connection) {\n      if (connection.queueEntry && connection.queueEntry.callback) {\n        try {\n          connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            messageId: connection.queueEntry.messageId,\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n\n        connection.queueEntry = false;\n      }\n    }\n  }, {\n    key: \"_requeueEntryOnConnectionClose\",\n    value: function _requeueEntryOnConnectionClose(connection) {\n      connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n      this.logger.debug({\n        tnx: 'pool',\n        cid: connection.id,\n        messageId: connection.queueEntry.messageId,\n        action: 'requeue'\n      }, 'Re-queued message <%s> for #%s. Attempt: #%s', connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);\n\n      this._queue.unshift(connection.queueEntry);\n\n      connection.queueEntry = false;\n    }\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n\n  }, {\n    key: \"_continueProcessing\",\n    value: function _continueProcessing() {\n      var _this6 = this;\n\n      if (this._closed) {\n        this.close();\n      } else {\n        setTimeout(function () {\n          return _this6._processMessages();\n        }, 100);\n      }\n    }\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n\n  }, {\n    key: \"_removeConnection\",\n    value: function _removeConnection(connection) {\n      var index = this._connections.indexOf(connection);\n\n      if (index !== -1) {\n        this._connections.splice(index, 1);\n      }\n    }\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n\n  }, {\n    key: \"_checkRateLimit\",\n    value: function _checkRateLimit(callback) {\n      var _this7 = this;\n\n      if (!this._rateLimit.limit) {\n        return callback();\n      }\n\n      var now = Date.now();\n\n      if (this._rateLimit.counter < this._rateLimit.limit) {\n        return callback();\n      }\n\n      this._rateLimit.waiting.push(callback);\n\n      if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n        return this._clearRateLimit();\n      } else if (!this._rateLimit.timeout) {\n        this._rateLimit.timeout = setTimeout(function () {\n          return _this7._clearRateLimit();\n        }, this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n        this._rateLimit.checkpoint = now;\n      }\n    }\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n\n  }, {\n    key: \"_clearRateLimit\",\n    value: function _clearRateLimit() {\n      clearTimeout(this._rateLimit.timeout);\n      this._rateLimit.timeout = null;\n      this._rateLimit.counter = 0;\n      this._rateLimit.checkpoint = false; // resume all paused connections\n\n      while (this._rateLimit.waiting.length) {\n        var cb = this._rateLimit.waiting.shift();\n\n        setImmediate(cb);\n      }\n    }\n    /**\n     * Returns true if there are free slots in the queue\n     */\n\n  }, {\n    key: \"isIdle\",\n    value: function isIdle() {\n      return this.idling;\n    }\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(callback) {\n      var _this8 = this;\n\n      var promise;\n\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n\n      var auth = new PoolResource(this).auth;\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var options = _this8.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this8.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          return callback(new Error('Connection closed'));\n        });\n\n        var finalize = function finalize() {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.quit();\n          return callback(null, true);\n        };\n\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          if (auth && (connection.allowsAuth || options.forceAuth)) {\n            connection.login(auth, function (err) {\n              if (returned) {\n                return;\n              }\n\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n\n              finalize();\n            });\n          } else {\n            finalize();\n          }\n        });\n      });\n      return promise;\n    }\n  }]);\n\n  return SMTPPool;\n}(EventEmitter); // expose to the world\n\n\nmodule.exports = SMTPPool;","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/smtp-pool/index.js"],"names":["EventEmitter","require","PoolResource","SMTPConnection","wellKnown","shared","packageData","SMTPPool","options","url","urlData","service","getSocket","parseConnectionUrl","assign","maxConnections","maxMessages","logger","getLogger","component","connection","name","version","_rateLimit","counter","timeout","waiting","checkpoint","delta","Number","rateDelta","limit","rateLimit","_closed","_queue","_connections","_connectionCounter","idling","setImmediate","emit","callback","mail","push","requeueAttempts","length","_processMessages","len","clearTimeout","i","available","close","info","tnx","cid","id","action","debug","invokeCallbacks","entry","shift","Error","E","error","err","message","_createConnection","queueEntry","messageId","getHeader","replace","messages","Date","now","send","on","once","code","_removeConnection","_continueProcessing","setTimeout","_shouldRequeuOnConnectionClose","_requeueEntryOnConnectionClose","_failDeliveryOnConnectionClose","maxRequeues","undefined","unshift","index","indexOf","splice","_clearRateLimit","cb","promise","Promise","resolve","reject","callbackPromise","auth","socketOptions","remoteAddress","remotePort","destHost","host","destPort","port","Object","keys","forEach","key","returned","finalize","quit","connect","allowsAuth","forceAuth","login","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst PoolResource = require('./pool-resource');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nclass SMTPPool extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.options.maxConnections = this.options.maxConnections || 5;\n        this.options.maxMessages = this.options.maxMessages || 100;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-pool'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP (pool)';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        this._rateLimit = {\n            counter: 0,\n            timeout: null,\n            waiting: [],\n            checkpoint: false,\n            delta: Number(this.options.rateDelta) || 1000,\n            limit: Number(this.options.rateLimit) || 0\n        };\n        this._closed = false;\n        this._queue = [];\n        this._connections = [];\n        this._connectionCounter = 0;\n\n        this.idling = true;\n\n        setImmediate(() => {\n            if (this.idling) {\n                this.emit('idle');\n            }\n        });\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        if (this._closed) {\n            return false;\n        }\n\n        this._queue.push({\n            mail,\n            requeueAttempts: 0,\n            callback\n        });\n\n        if (this.idling && this._queue.length >= this.options.maxConnections) {\n            this.idling = false;\n        }\n\n        setImmediate(() => this._processMessages());\n\n        return true;\n    }\n\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n    close() {\n        let connection;\n        let len = this._connections.length;\n        this._closed = true;\n\n        // clear rate limit timer if it exists\n        clearTimeout(this._rateLimit.timeout);\n\n        if (!len && !this._queue.length) {\n            return;\n        }\n\n        // remove all available connections\n        for (let i = len - 1; i >= 0; i--) {\n            if (this._connections[i] && this._connections[i].available) {\n                connection = this._connections[i];\n                connection.close();\n                this.logger.info(\n                    {\n                        tnx: 'connection',\n                        cid: connection.id,\n                        action: 'removed'\n                    },\n                    'Connection #%s removed',\n                    connection.id\n                );\n            }\n        }\n\n        if (len && !this._connections.length) {\n            this.logger.debug(\n                {\n                    tnx: 'connection'\n                },\n                'All connections removed'\n            );\n        }\n\n        if (!this._queue.length) {\n            return;\n        }\n\n        // make sure that entire queue would be cleaned\n        let invokeCallbacks = () => {\n            if (!this._queue.length) {\n                this.logger.debug(\n                    {\n                        tnx: 'connection'\n                    },\n                    'Pending queue entries cleared'\n                );\n                return;\n            }\n            let entry = this._queue.shift();\n            if (entry && typeof entry.callback === 'function') {\n                try {\n                    entry.callback(new Error('Connection pool was closed'));\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n            }\n            setImmediate(invokeCallbacks);\n        };\n        setImmediate(invokeCallbacks);\n    }\n\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n    _processMessages() {\n        let connection;\n        let i, len;\n\n        // do nothing if already closed\n        if (this._closed) {\n            return;\n        }\n\n        // do nothing if queue is empty\n        if (!this._queue.length) {\n            if (!this.idling) {\n                // no pending jobs\n                this.idling = true;\n                this.emit('idle');\n            }\n            return;\n        }\n\n        // find first available connection\n        for (i = 0, len = this._connections.length; i < len; i++) {\n            if (this._connections[i].available) {\n                connection = this._connections[i];\n                break;\n            }\n        }\n\n        if (!connection && this._connections.length < this.options.maxConnections) {\n            connection = this._createConnection();\n        }\n\n        if (!connection) {\n            // no more free connection slots available\n            this.idling = false;\n            return;\n        }\n\n        // check if there is free space in the processing queue\n        if (!this.idling && this._queue.length < this.options.maxConnections) {\n            this.idling = true;\n            this.emit('idle');\n        }\n\n        let entry = (connection.queueEntry = this._queue.shift());\n        entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n\n        connection.available = false;\n\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: entry.messageId,\n                action: 'assign'\n            },\n            'Assigned message <%s> to #%s (%s)',\n            entry.messageId,\n            connection.id,\n            connection.messages + 1\n        );\n\n        if (this._rateLimit.limit) {\n            this._rateLimit.counter++;\n            if (!this._rateLimit.checkpoint) {\n                this._rateLimit.checkpoint = Date.now();\n            }\n        }\n\n        connection.send(entry.mail, (err, info) => {\n            // only process callback if current handler is not changed\n            if (entry === connection.queueEntry) {\n                try {\n                    entry.callback(err, info);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n        });\n    }\n\n    /**\n     * Creates a new pool resource\n     */\n    _createConnection() {\n        let connection = new PoolResource(this);\n\n        connection.id = ++this._connectionCounter;\n\n        this.logger.info(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                action: 'conection'\n            },\n            'Created new pool resource #%s',\n            connection.id\n        );\n\n        // resource comes available\n        connection.on('available', () => {\n            this.logger.debug(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'available'\n                },\n                'Connection #%s became available',\n                connection.id\n            );\n\n            if (this._closed) {\n                // if already closed run close() that will remove this connections from connections list\n                this.close();\n            } else {\n                // check if there's anything else to send\n                this._processMessages();\n            }\n        });\n\n        // resource is terminated with an error\n        connection.once('error', err => {\n            if (err.code !== 'EMAXLIMIT') {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'pool',\n                        cid: connection.id\n                    },\n                    'Pool Error for #%s: %s',\n                    connection.id,\n                    err.message\n                );\n            } else {\n                this.logger.debug(\n                    {\n                        tnx: 'pool',\n                        cid: connection.id,\n                        action: 'maxlimit'\n                    },\n                    'Max messages limit exchausted for #%s',\n                    connection.id\n                );\n            }\n\n            if (connection.queueEntry) {\n                try {\n                    connection.queueEntry.callback(err);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n\n            // remove the erroneus connection from connections list\n            this._removeConnection(connection);\n\n            this._continueProcessing();\n        });\n\n        connection.once('close', () => {\n            this.logger.info(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'closed'\n                },\n                'Connection #%s was closed',\n                connection.id\n            );\n\n            this._removeConnection(connection);\n\n            if (connection.queueEntry) {\n                // If the connection closed when sending, add the message to the queue again\n                // if max number of requeues is not reached yet\n                // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n                // in the next event loop\n                setTimeout(() => {\n                    if (connection.queueEntry) {\n                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                            this._requeueEntryOnConnectionClose(connection);\n                        } else {\n                            this._failDeliveryOnConnectionClose(connection);\n                        }\n                    }\n                    this._continueProcessing();\n                }, 50);\n            } else {\n                this._continueProcessing();\n            }\n        });\n\n        this._connections.push(connection);\n\n        return connection;\n    }\n\n    _shouldRequeuOnConnectionClose(queueEntry) {\n        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n            return true;\n        }\n\n        return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n\n    _failDeliveryOnConnectionClose(connection) {\n        if (connection.queueEntry && connection.queueEntry.callback) {\n            try {\n                connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'callback',\n                        messageId: connection.queueEntry.messageId,\n                        cid: connection.id\n                    },\n                    'Callback error for #%s: %s',\n                    connection.id,\n                    E.message\n                );\n            }\n            connection.queueEntry = false;\n        }\n    }\n\n    _requeueEntryOnConnectionClose(connection) {\n        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: connection.queueEntry.messageId,\n                action: 'requeue'\n            },\n            'Re-queued message <%s> for #%s. Attempt: #%s',\n            connection.queueEntry.messageId,\n            connection.id,\n            connection.queueEntry.requeueAttempts\n        );\n        this._queue.unshift(connection.queueEntry);\n        connection.queueEntry = false;\n    }\n\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n    _continueProcessing() {\n        if (this._closed) {\n            this.close();\n        } else {\n            setTimeout(() => this._processMessages(), 100);\n        }\n    }\n\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n    _removeConnection(connection) {\n        let index = this._connections.indexOf(connection);\n\n        if (index !== -1) {\n            this._connections.splice(index, 1);\n        }\n    }\n\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n    _checkRateLimit(callback) {\n        if (!this._rateLimit.limit) {\n            return callback();\n        }\n\n        let now = Date.now();\n\n        if (this._rateLimit.counter < this._rateLimit.limit) {\n            return callback();\n        }\n\n        this._rateLimit.waiting.push(callback);\n\n        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n            return this._clearRateLimit();\n        } else if (!this._rateLimit.timeout) {\n            this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n            this._rateLimit.checkpoint = now;\n        }\n    }\n\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n    _clearRateLimit() {\n        clearTimeout(this._rateLimit.timeout);\n        this._rateLimit.timeout = null;\n        this._rateLimit.counter = 0;\n        this._rateLimit.checkpoint = false;\n\n        // resume all paused connections\n        while (this._rateLimit.waiting.length) {\n            let cb = this._rateLimit.waiting.shift();\n            setImmediate(cb);\n        }\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n    isIdle() {\n        return this.idling;\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let auth = new PoolResource(this).auth;\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPPool;\n"]},"metadata":{},"sourceType":"script"}