{"ast":null,"code":"var _slicedToArray = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/**\n * Module dependencies.\n */\nvar FTP = require('ftp');\n\nvar path = require('path');\n\nvar NotFoundError = require('./notfound');\n\nvar NotModifiedError = require('./notmodified');\n\nvar debug = require('debug')('get-uri:ftp');\n/**\n * Module exports.\n */\n\n\nmodule.exports = get;\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  var cache = opts.cache;\n  var client = new FTP();\n  var filepath = parsed.pathname;\n  var lastModified;\n  client.once('error', onerror);\n  client.once('ready', onready);\n  client.once('greeting', ongreeting);\n\n  function onready() {\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    client.lastMod(filepath, onlastmod);\n  }\n\n  function ongreeting(greeting) {\n    debug('FTP greeting: %o', greeting);\n  }\n\n  function onerror(err) {\n    client.end();\n    fn(err);\n  }\n\n  function onfile(err, stream) {\n    if (err) return onerror(err);\n    stream.once('end', onend);\n    stream.lastModified = lastModified;\n    fn(null, stream);\n  }\n\n  function onend() {\n    // close the FTP client socket connection\n    client.end();\n  }\n\n  function getFile() {\n    client.get(filepath, onfile);\n  }\n\n  function onlastmod(err, lastmod) {\n    // handle the \"file not found\" error code\n    if (err) {\n      if (550 == err.code) {\n        onerror(new NotFoundError());\n      } // any other error then we'll try the LIST command instead\n\n    }\n\n    if (lastmod) {\n      setLastMod(lastmod);\n    } else {\n      // try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      var dir = path.dirname(filepath);\n      client.list(dir, onlist);\n    }\n  }\n\n  function setLastMod(lastmod) {\n    lastModified = lastmod;\n\n    if (cache && isNotModified()) {\n      // file is the same as in the \"cache\", return a not modified error\n      onerror(new NotModifiedError());\n    } else {\n      // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      setTimeout(client.get.bind(client, filepath, onfile), 10);\n    }\n  }\n\n  function onlist(err, list) {\n    if (err) return onerror(err);\n    var name = path.basename(filepath); // attempt to find the \"entry\" with a matching \"name\"\n\n    var entry;\n\n    for (var i = 0; i < list.length; i++) {\n      entry = list[i];\n      debug('file %o: %o', i, entry.name);\n\n      if (entry.name == name) {\n        break;\n      }\n\n      entry = null;\n    }\n\n    if (entry) {\n      setLastMod(entry.date);\n    } else {\n      onerror(new NotFoundError());\n    }\n  } // called when `lastModified` is set, and a \"cache\" stream was provided\n\n\n  function isNotModified() {\n    return +cache.lastModified == +lastModified;\n  }\n\n  opts.host = parsed.hostname || parsed.host || 'localhost';\n  opts.port = parseInt(parsed.port, 10) || 21;\n  if (debug.enabled) opts.debug = debug;\n\n  if (parsed.auth) {\n    var _parsed$auth$split = parsed.auth.split(\":\"),\n        _parsed$auth$split2 = _slicedToArray(_parsed$auth$split, 2),\n        user = _parsed$auth$split2[0],\n        password = _parsed$auth$split2[1];\n\n    opts.user = user;\n    opts.password = password;\n  }\n\n  client.connect(opts);\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/get-uri/ftp.js"],"names":["FTP","require","path","NotFoundError","NotModifiedError","debug","module","exports","get","parsed","opts","fn","cache","client","filepath","pathname","lastModified","once","onerror","onready","ongreeting","lastMod","onlastmod","greeting","err","end","onfile","stream","onend","getFile","lastmod","code","setLastMod","dir","dirname","list","onlist","isNotModified","setTimeout","bind","name","basename","entry","i","length","date","host","hostname","port","parseInt","enabled","auth","split","user","password","connect"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar FTP = require('ftp');\nvar path = require('path');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:ftp');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n *\n * @api protected\n */\n\nfunction get (parsed, opts, fn) {\n  var cache = opts.cache;\n  var client = new FTP();\n  var filepath = parsed.pathname;\n  var lastModified;\n\n  client.once('error', onerror);\n  client.once('ready', onready);\n  client.once('greeting', ongreeting);\n\n  function onready () {\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    client.lastMod(filepath, onlastmod);\n  }\n\n  function ongreeting (greeting) {\n    debug('FTP greeting: %o', greeting);\n  }\n\n  function onerror (err) {\n    client.end();\n    fn(err);\n  }\n\n  function onfile (err, stream) {\n    if (err) return onerror(err);\n    stream.once('end', onend);\n    stream.lastModified = lastModified;\n    fn(null, stream);\n  }\n\n  function onend () {\n    // close the FTP client socket connection\n    client.end();\n  }\n\n  function getFile () {\n    client.get(filepath, onfile);\n  }\n\n  function onlastmod (err, lastmod) {\n    // handle the \"file not found\" error code\n    if (err) {\n      if (550 == err.code) {\n        onerror(new NotFoundError());\n      }\n      // any other error then we'll try the LIST command instead\n    }\n    if (lastmod) {\n      setLastMod(lastmod);\n    } else {\n      // try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      var dir = path.dirname(filepath);\n      client.list(dir, onlist);\n    }\n  }\n\n  function setLastMod (lastmod) {\n    lastModified = lastmod;\n    if (cache && isNotModified()) {\n      // file is the same as in the \"cache\", return a not modified error\n      onerror(new NotModifiedError());\n    } else {\n      // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      setTimeout(client.get.bind(client, filepath, onfile), 10);\n    }\n  }\n\n  function onlist (err, list) {\n    if (err) return onerror(err);\n    var name = path.basename(filepath);\n\n    // attempt to find the \"entry\" with a matching \"name\"\n    var entry;\n    for (var i = 0; i < list.length; i++) {\n      entry = list[i];\n      debug('file %o: %o', i, entry.name);\n      if (entry.name == name) {\n        break;\n      }\n      entry = null;\n    }\n\n    if (entry) {\n      setLastMod(entry.date);\n    } else {\n      onerror(new NotFoundError());\n    }\n  }\n\n  // called when `lastModified` is set, and a \"cache\" stream was provided\n  function isNotModified () {\n    return +cache.lastModified == +lastModified;\n  }\n\n  opts.host = parsed.hostname || parsed.host || 'localhost';\n  opts.port = parseInt(parsed.port, 10) || 21;\n  if (debug.enabled) opts.debug = debug;\n\n  if (parsed.auth) {\n    const [user, password] = parsed.auth.split(\":\");\n    opts.user = user;\n    opts.password = password;\n  }\n  \n  client.connect(opts);\n}\n"]},"metadata":{},"sourceType":"script"}