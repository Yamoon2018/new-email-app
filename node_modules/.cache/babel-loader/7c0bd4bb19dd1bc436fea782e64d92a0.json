{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\n\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  }\n\n  return buffer.toString('base64');\n}\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  var result = [];\n  var pos = 0;\n  var chunkLength = lineLength * 1024;\n\n  while (pos < str.length) {\n    var wrappedLines = str.substr(pos, chunkLength).replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n    result.push(wrappedLines);\n    pos += chunkLength;\n  }\n\n  return result.join('\\r\\n').trim();\n}\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nvar Encoder = /*#__PURE__*/function (_Transform) {\n  _inherits(Encoder, _Transform);\n\n  var _super = _createSuper(Encoder);\n\n  function Encoder(options) {\n    var _this;\n\n    _classCallCheck(this, Encoder);\n\n    _this = _super.call(this); // init Transform\n\n    _this.options = options || {};\n\n    if (_this.options.lineLength !== false) {\n      _this.options.lineLength = _this.options.lineLength || 76;\n    }\n\n    _this._curLine = '';\n    _this._remainingBytes = false;\n    _this.inputBytes = 0;\n    _this.outputBytes = 0;\n    return _this;\n  }\n\n  _createClass(Encoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (encoding !== 'buffer') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (!chunk || !chunk.length) {\n        return setImmediate(done);\n      }\n\n      this.inputBytes += chunk.length;\n\n      if (this._remainingBytes && this._remainingBytes.length) {\n        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n        this._remainingBytes = false;\n      }\n\n      if (chunk.length % 3) {\n        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n        chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n      } else {\n        this._remainingBytes = false;\n      }\n\n      var b64 = this._curLine + encode(chunk);\n\n      if (this.options.lineLength) {\n        b64 = wrap(b64, this.options.lineLength); // remove last line as it is still most probably incomplete\n\n        var lastLF = b64.lastIndexOf('\\n');\n\n        if (lastLF < 0) {\n          this._curLine = b64;\n          b64 = '';\n        } else if (lastLF === b64.length - 1) {\n          this._curLine = '';\n        } else {\n          this._curLine = b64.substr(lastLF + 1);\n          b64 = b64.substr(0, lastLF + 1);\n        }\n      }\n\n      if (b64) {\n        this.outputBytes += b64.length;\n        this.push(Buffer.from(b64, 'ascii'));\n      }\n\n      setImmediate(done);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._remainingBytes && this._remainingBytes.length) {\n        this._curLine += encode(this._remainingBytes);\n      }\n\n      if (this._curLine) {\n        this._curLine = wrap(this._curLine, this.options.lineLength);\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n        this._curLine = '';\n      }\n\n      done();\n    }\n  }]);\n\n  return Encoder;\n}(Transform); // expose to the world\n\n\nmodule.exports = {\n  encode: encode,\n  wrap: wrap,\n  Encoder: Encoder\n};","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/base64/index.js"],"names":["Transform","require","encode","buffer","Buffer","from","toString","wrap","str","lineLength","length","result","pos","chunkLength","wrappedLines","substr","replace","RegExp","trim","push","join","Encoder","options","_curLine","_remainingBytes","inputBytes","outputBytes","chunk","encoding","done","setImmediate","concat","slice","b64","lastLF","lastIndexOf","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    return buffer.toString('base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let result = [];\n    let pos = 0;\n    let chunkLength = lineLength * 1024;\n    while (pos < str.length) {\n        let wrappedLines = str\n            .substr(pos, chunkLength)\n            .replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n')\n            .trim();\n        result.push(wrappedLines);\n        pos += chunkLength;\n    }\n\n    return result.join('\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n        this._remainingBytes = false;\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return setImmediate(done);\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this._remainingBytes && this._remainingBytes.length) {\n            chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n            this._remainingBytes = false;\n        }\n\n        if (chunk.length % 3) {\n            this._remainingBytes = chunk.slice(chunk.length - (chunk.length % 3));\n            chunk = chunk.slice(0, chunk.length - (chunk.length % 3));\n        } else {\n            this._remainingBytes = false;\n        }\n\n        let b64 = this._curLine + encode(chunk);\n\n        if (this.options.lineLength) {\n            b64 = wrap(b64, this.options.lineLength);\n\n            // remove last line as it is still most probably incomplete\n            let lastLF = b64.lastIndexOf('\\n');\n            if (lastLF < 0) {\n                this._curLine = b64;\n                b64 = '';\n            } else if (lastLF === b64.length - 1) {\n                this._curLine = '';\n            } else {\n                this._curLine = b64.substr(lastLF + 1);\n                b64 = b64.substr(0, lastLF + 1);\n            }\n        }\n\n        if (b64) {\n            this.outputBytes += b64.length;\n            this.push(Buffer.from(b64, 'ascii'));\n        }\n\n        setImmediate(done);\n    }\n\n    _flush(done) {\n        if (this._remainingBytes && this._remainingBytes.length) {\n            this._curLine += encode(this._remainingBytes);\n        }\n\n        if (this._curLine) {\n            this._curLine = wrap(this._curLine, this.options.lineLength);\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n            this._curLine = '';\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n"]},"metadata":{},"sourceType":"script"}