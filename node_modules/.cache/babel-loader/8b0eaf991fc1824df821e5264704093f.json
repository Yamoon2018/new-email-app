{"ast":null,"code":"\"use strict\";\n/* global module, require */\n\nmodule.exports = function () {\n  \"use strict\"; // Get a promise object. This may be native, or it may be polyfilled\n\n  var ES6Promise = require(\"./promise.js\");\n  /**\n   * thatLooksLikeAPromiseToMe()\n   *\n   * Duck-types a promise.\n   *\n   * @param {object} o\n   * @return {bool} True if this resembles a promise\n   */\n\n\n  function thatLooksLikeAPromiseToMe(o) {\n    return o && typeof o.then === \"function\" && typeof o.catch === \"function\";\n  }\n  /**\n   * promisify()\n   *\n   * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n   * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n   * and rejects when `error` is truthy. You can also supply settings object as the second argument.\n   *\n   * @param {function} original - The function to promisify\n   * @param {object} settings - Settings object\n   * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`\n   * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?\n   * @return {function} A promisified version of `original`\n   */\n\n\n  return function promisify(original, settings) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var returnMultipleArguments = settings && settings.multiArgs;\n      var target = void 0;\n\n      if (settings && settings.thisArg) {\n        target = settings.thisArg;\n      } else if (settings) {\n        target = settings;\n      } // Return the promisified function\n\n\n      return new ES6Promise(function (resolve, reject) {\n        // Append the callback bound to the context\n        args.push(function callback(err) {\n          if (err) {\n            return reject(err);\n          }\n\n          for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            values[_key2 - 1] = arguments[_key2];\n          }\n\n          if (false === !!returnMultipleArguments) {\n            return resolve(values[0]);\n          }\n\n          resolve(values);\n        }); // Call the function\n\n        var response = original.apply(target, args); // If it looks like original already returns a promise,\n        // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.\n\n        if (thatLooksLikeAPromiseToMe(response)) {\n          resolve(response);\n        }\n      });\n    };\n  };\n}();","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/es6-promisify/dist/promisify.js"],"names":["module","exports","ES6Promise","require","thatLooksLikeAPromiseToMe","o","then","catch","promisify","original","settings","_len","arguments","length","args","Array","_key","returnMultipleArguments","multiArgs","target","thisArg","resolve","reject","push","callback","err","_len2","values","_key2","response","apply"],"mappings":"AAAA;AAEA;;AACAA,MAAM,CAACC,OAAP,GAAiB,YAAY;AAEzB,eAFyB,CAIzB;;AAEA,MAAIC,UAAU,GAAGC,OAAO,CAAC,cAAD,CAAxB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,yBAAT,CAAmCC,CAAnC,EAAsC;AAClC,WAAOA,CAAC,IAAI,OAAOA,CAAC,CAACC,IAAT,KAAkB,UAAvB,IAAqC,OAAOD,CAAC,CAACE,KAAT,KAAmB,UAA/D;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAO,SAASC,SAAT,CAAmBC,QAAnB,EAA6BC,QAA7B,EAAuC;AAE1C,WAAO,YAAY;AACf,WAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAGC,KAAK,CAACJ,IAAD,CAAzC,EAAiDK,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGL,IAAvE,EAA6EK,IAAI,EAAjF,EAAqF;AACjFF,QAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;AACH;;AAED,UAAIC,uBAAuB,GAAGP,QAAQ,IAAIA,QAAQ,CAACQ,SAAnD;AAEA,UAAIC,MAAM,GAAG,KAAK,CAAlB;;AACA,UAAIT,QAAQ,IAAIA,QAAQ,CAACU,OAAzB,EAAkC;AAC9BD,QAAAA,MAAM,GAAGT,QAAQ,CAACU,OAAlB;AACH,OAFD,MAEO,IAAIV,QAAJ,EAAc;AACjBS,QAAAA,MAAM,GAAGT,QAAT;AACH,OAZc,CAcf;;;AACA,aAAO,IAAIR,UAAJ,CAAe,UAAUmB,OAAV,EAAmBC,MAAnB,EAA2B;AAE7C;AACAR,QAAAA,IAAI,CAACS,IAAL,CAAU,SAASC,QAAT,CAAkBC,GAAlB,EAAuB;AAE7B,cAAIA,GAAJ,EAAS;AACL,mBAAOH,MAAM,CAACG,GAAD,CAAb;AACH;;AAED,eAAK,IAAIC,KAAK,GAAGd,SAAS,CAACC,MAAtB,EAA8Bc,MAAM,GAAGZ,KAAK,CAACW,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAzB,CAA5C,EAAyEE,KAAK,GAAG,CAAtF,EAAyFA,KAAK,GAAGF,KAAjG,EAAwGE,KAAK,EAA7G,EAAiH;AAC7GD,YAAAA,MAAM,CAACC,KAAK,GAAG,CAAT,CAAN,GAAoBhB,SAAS,CAACgB,KAAD,CAA7B;AACH;;AAED,cAAI,UAAU,CAAC,CAACX,uBAAhB,EAAyC;AACrC,mBAAOI,OAAO,CAACM,MAAM,CAAC,CAAD,CAAP,CAAd;AACH;;AAEDN,UAAAA,OAAO,CAACM,MAAD,CAAP;AACH,SAfD,EAH6C,CAoB7C;;AACA,YAAIE,QAAQ,GAAGpB,QAAQ,CAACqB,KAAT,CAAeX,MAAf,EAAuBL,IAAvB,CAAf,CArB6C,CAuB7C;AACA;;AACA,YAAIV,yBAAyB,CAACyB,QAAD,CAA7B,EAAyC;AACrCR,UAAAA,OAAO,CAACQ,QAAD,CAAP;AACH;AACJ,OA5BM,CAAP;AA6BH,KA5CD;AA6CH,GA/CD;AAgDH,CAjFgB,EAAjB","sourcesContent":["\"use strict\";\n\n/* global module, require */\nmodule.exports = function () {\n\n    \"use strict\";\n\n    // Get a promise object. This may be native, or it may be polyfilled\n\n    var ES6Promise = require(\"./promise.js\");\n\n    /**\n     * thatLooksLikeAPromiseToMe()\n     *\n     * Duck-types a promise.\n     *\n     * @param {object} o\n     * @return {bool} True if this resembles a promise\n     */\n    function thatLooksLikeAPromiseToMe(o) {\n        return o && typeof o.then === \"function\" && typeof o.catch === \"function\";\n    }\n\n    /**\n     * promisify()\n     *\n     * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n     * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n     * and rejects when `error` is truthy. You can also supply settings object as the second argument.\n     *\n     * @param {function} original - The function to promisify\n     * @param {object} settings - Settings object\n     * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`\n     * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?\n     * @return {function} A promisified version of `original`\n     */\n    return function promisify(original, settings) {\n\n        return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var returnMultipleArguments = settings && settings.multiArgs;\n\n            var target = void 0;\n            if (settings && settings.thisArg) {\n                target = settings.thisArg;\n            } else if (settings) {\n                target = settings;\n            }\n\n            // Return the promisified function\n            return new ES6Promise(function (resolve, reject) {\n\n                // Append the callback bound to the context\n                args.push(function callback(err) {\n\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                        values[_key2 - 1] = arguments[_key2];\n                    }\n\n                    if (false === !!returnMultipleArguments) {\n                        return resolve(values[0]);\n                    }\n\n                    resolve(values);\n                });\n\n                // Call the function\n                var response = original.apply(target, args);\n\n                // If it looks like original already returns a promise,\n                // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.\n                if (thatLooksLikeAPromiseToMe(response)) {\n                    resolve(response);\n                }\n            });\n        };\n    };\n}();"]},"metadata":{},"sourceType":"script"}