{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar packageData = require('../../package.json');\n\nvar shared = require('../shared');\n\nvar LeWindows = require('../sendmail-transport/le-windows');\n\nvar LeUnix = require('../sendmail-transport/le-unix');\n/**\n * Generates a Transport object for streaming\n *\n * Possible options can be the following:\n *\n *  * **buffer** if true, then returns the message as a Buffer object instead of a stream\n *  * **newline** either 'windows' or 'unix'\n *\n * @constructor\n * @param {Object} optional config parameter\n */\n\n\nvar StreamTransport = /*#__PURE__*/function () {\n  function StreamTransport(options) {\n    _classCallCheck(this, StreamTransport);\n\n    options = options || {};\n    this.options = options || {};\n    this.name = 'StreamTransport';\n    this.version = packageData.version;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'stream-transport'\n    });\n    this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n  }\n  /**\n   * Compiles a mailcomposer message and forwards it to handler that sends it\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n\n\n  _createClass(StreamTransport, [{\n    key: \"send\",\n    value: function send(mail, done) {\n      var _this = this;\n\n      // We probably need this in the output\n      mail.message.keepBcc = true;\n      var envelope = mail.data.envelope || mail.message.getEnvelope();\n      var messageId = mail.message.messageId();\n      var recipients = [].concat(envelope.to || []);\n\n      if (recipients.length > 3) {\n        recipients.push('...and ' + recipients.splice(2).length + ' more');\n      }\n\n      this.logger.info({\n        tnx: 'send',\n        messageId: messageId\n      }, 'Sending message %s to <%s> using %s line breaks', messageId, recipients.join(', '), this.winbreak ? '<CR><LF>' : '<LF>');\n      setImmediate(function () {\n        var sourceStream;\n        var stream;\n        var transform;\n\n        try {\n          transform = _this.winbreak ? new LeWindows() : new LeUnix();\n          sourceStream = mail.message.createReadStream();\n          stream = sourceStream.pipe(transform);\n          sourceStream.on('error', function (err) {\n            return stream.emit('error', err);\n          });\n        } catch (E) {\n          _this.logger.error({\n            err: E,\n            tnx: 'send',\n            messageId: messageId\n          }, 'Creating send stream failed for %s. %s', messageId, E.message);\n\n          return done(E);\n        }\n\n        if (!_this.options.buffer) {\n          stream.once('error', function (err) {\n            _this.logger.error({\n              err: err,\n              tnx: 'send',\n              messageId: messageId\n            }, 'Failed creating message for %s. %s', messageId, err.message);\n          });\n          return done(null, {\n            envelope: mail.data.envelope || mail.message.getEnvelope(),\n            messageId: messageId,\n            message: stream\n          });\n        }\n\n        var chunks = [];\n        var chunklen = 0;\n        stream.on('readable', function () {\n          var chunk;\n\n          while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n          }\n        });\n        stream.once('error', function (err) {\n          _this.logger.error({\n            err: err,\n            tnx: 'send',\n            messageId: messageId\n          }, 'Failed creating message for %s. %s', messageId, err.message);\n\n          return done(err);\n        });\n        stream.on('end', function () {\n          return done(null, {\n            envelope: mail.data.envelope || mail.message.getEnvelope(),\n            messageId: messageId,\n            message: Buffer.concat(chunks, chunklen)\n          });\n        });\n      });\n    }\n  }]);\n\n  return StreamTransport;\n}();\n\nmodule.exports = StreamTransport;","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/stream-transport/index.js"],"names":["packageData","require","shared","LeWindows","LeUnix","StreamTransport","options","name","version","logger","getLogger","component","winbreak","includes","newline","toString","toLowerCase","mail","done","message","keepBcc","envelope","data","getEnvelope","messageId","recipients","concat","to","length","push","splice","info","tnx","join","setImmediate","sourceStream","stream","transform","createReadStream","pipe","on","err","emit","E","error","buffer","once","chunks","chunklen","chunk","read","Buffer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst packageData = require('../../package.json');\nconst shared = require('../shared');\nconst LeWindows = require('../sendmail-transport/le-windows');\nconst LeUnix = require('../sendmail-transport/le-unix');\n\n/**\n * Generates a Transport object for streaming\n *\n * Possible options can be the following:\n *\n *  * **buffer** if true, then returns the message as a Buffer object instead of a stream\n *  * **newline** either 'windows' or 'unix'\n *\n * @constructor\n * @param {Object} optional config parameter\n */\nclass StreamTransport {\n    constructor(options) {\n        options = options || {};\n\n        this.options = options || {};\n\n        this.name = 'StreamTransport';\n        this.version = packageData.version;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'stream-transport'\n        });\n\n        this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n    }\n\n    /**\n     * Compiles a mailcomposer message and forwards it to handler that sends it\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // We probably need this in the output\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        this.logger.info(\n            {\n                tnx: 'send',\n                messageId\n            },\n            'Sending message %s to <%s> using %s line breaks',\n            messageId,\n            recipients.join(', '),\n            this.winbreak ? '<CR><LF>' : '<LF>'\n        );\n\n        setImmediate(() => {\n            let sourceStream;\n            let stream;\n            let transform;\n\n            try {\n                transform = this.winbreak ? new LeWindows() : new LeUnix();\n                sourceStream = mail.message.createReadStream();\n                stream = sourceStream.pipe(transform);\n                sourceStream.on('error', err => stream.emit('error', err));\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Creating send stream failed for %s. %s',\n                    messageId,\n                    E.message\n                );\n                return done(E);\n            }\n\n            if (!this.options.buffer) {\n                stream.once('error', err => {\n                    this.logger.error(\n                        {\n                            err,\n                            tnx: 'send',\n                            messageId\n                        },\n                        'Failed creating message for %s. %s',\n                        messageId,\n                        err.message\n                    );\n                });\n                return done(null, {\n                    envelope: mail.data.envelope || mail.message.getEnvelope(),\n                    messageId,\n                    message: stream\n                });\n            }\n\n            let chunks = [];\n            let chunklen = 0;\n            stream.on('readable', () => {\n                let chunk;\n                while ((chunk = stream.read()) !== null) {\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n\n            stream.once('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Failed creating message for %s. %s',\n                    messageId,\n                    err.message\n                );\n                return done(err);\n            });\n\n            stream.on('end', () =>\n                done(null, {\n                    envelope: mail.data.envelope || mail.message.getEnvelope(),\n                    messageId,\n                    message: Buffer.concat(chunks, chunklen)\n                })\n            );\n        });\n    }\n}\n\nmodule.exports = StreamTransport;\n"]},"metadata":{},"sourceType":"script"}