{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n */\n\nvar parse = require('url').parse;\n\nvar debug = require('debug')('get-uri');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = getUri;\n/**\n * Supported \"protocols\".\n */\n\nexports.protocols = {\n  data: require('./data'),\n  file: require('./file'),\n  ftp: require('./ftp'),\n  http: require('./http'),\n  https: require('./https')\n};\n/**\n * Async function that returns a `stream.Readable` instance to the\n * callback function that will output the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @param {Function} fn callback function\n * @api public\n */\n\nfunction getUri(uri, opts, fn) {\n  debug('getUri(%o)', uri);\n\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = null;\n  }\n\n  if ('function' != typeof fn) {\n    throw new TypeError('a callback function must be provided');\n  }\n\n  if (!uri) return fn(new TypeError('must pass in a URI to \"get\"'));\n  var parsed = parse(uri);\n  var protocol = parsed.protocol;\n  if (!protocol) return fn(new TypeError('URI does not contain a protocol: ' + uri)); // strip trailing :\n\n  protocol = protocol.replace(/\\:$/, '');\n  var getter = exports.protocols[protocol];\n  if ('function' != typeof getter) return fn(new TypeError('unsupported protocol \"' + protocol + '\" specified in URI: ' + uri));\n  getter(parsed, opts || {}, fn);\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/get-uri/index.js"],"names":["parse","require","debug","module","exports","getUri","protocols","data","file","ftp","http","https","uri","opts","fn","TypeError","parsed","protocol","replace","getter"],"mappings":"AAAA;AAEA;AACA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,KAAD,CAAP,CAAeD,KAA3B;;AACA,IAAIE,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,SAAjB,CAAZ;AAEA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGC,MAA3B;AAEA;AACA;AACA;;AAEAD,OAAO,CAACE,SAAR,GAAoB;AAClBC,EAAAA,IAAI,EAAEN,OAAO,CAAC,QAAD,CADK;AAElBO,EAAAA,IAAI,EAAEP,OAAO,CAAC,QAAD,CAFK;AAGlBQ,EAAAA,GAAG,EAAER,OAAO,CAAC,OAAD,CAHM;AAIlBS,EAAAA,IAAI,EAAET,OAAO,CAAC,QAAD,CAJK;AAKlBU,EAAAA,KAAK,EAAEV,OAAO,CAAC,SAAD;AALI,CAApB;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASI,MAAT,CAAiBO,GAAjB,EAAsBC,IAAtB,EAA4BC,EAA5B,EAAgC;AAC9BZ,EAAAA,KAAK,CAAC,YAAD,EAAeU,GAAf,CAAL;;AAEA,MAAI,cAAc,OAAOC,IAAzB,EAA+B;AAC7BC,IAAAA,EAAE,GAAGD,IAAL;AACAA,IAAAA,IAAI,GAAG,IAAP;AACD;;AACD,MAAI,cAAc,OAAOC,EAAzB,EAA6B;AAC3B,UAAM,IAAIC,SAAJ,CAAc,sCAAd,CAAN;AACD;;AAED,MAAI,CAACH,GAAL,EAAU,OAAOE,EAAE,CAAC,IAAIC,SAAJ,CAAc,6BAAd,CAAD,CAAT;AAEV,MAAIC,MAAM,GAAGhB,KAAK,CAACY,GAAD,CAAlB;AACA,MAAIK,QAAQ,GAAGD,MAAM,CAACC,QAAtB;AACA,MAAI,CAACA,QAAL,EAAe,OAAOH,EAAE,CAAC,IAAIC,SAAJ,CAAc,sCAAsCH,GAApD,CAAD,CAAT,CAfe,CAiB9B;;AACAK,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAAX;AAEA,MAAIC,MAAM,GAAGf,OAAO,CAACE,SAAR,CAAkBW,QAAlB,CAAb;AAEA,MAAI,cAAc,OAAOE,MAAzB,EACE,OAAOL,EAAE,CAAC,IAAIC,SAAJ,CAAc,2BAA2BE,QAA3B,GAAsC,sBAAtC,GAA+DL,GAA7E,CAAD,CAAT;AAEFO,EAAAA,MAAM,CAACH,MAAD,EAASH,IAAI,IAAI,EAAjB,EAAqBC,EAArB,CAAN;AACD","sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar parse = require('url').parse;\nvar debug = require('debug')('get-uri');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = getUri;\n\n/**\n * Supported \"protocols\".\n */\n\nexports.protocols = {\n  data: require('./data'),\n  file: require('./file'),\n  ftp: require('./ftp'),\n  http: require('./http'),\n  https: require('./https')\n};\n\n/**\n * Async function that returns a `stream.Readable` instance to the\n * callback function that will output the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @param {Function} fn callback function\n * @api public\n */\n\nfunction getUri (uri, opts, fn) {\n  debug('getUri(%o)', uri);\n\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = null;\n  }\n  if ('function' != typeof fn) {\n    throw new TypeError('a callback function must be provided');\n  }\n\n  if (!uri) return fn(new TypeError('must pass in a URI to \"get\"'));\n\n  var parsed = parse(uri);\n  var protocol = parsed.protocol;\n  if (!protocol) return fn(new TypeError('URI does not contain a protocol: ' + uri));\n\n  // strip trailing :\n  protocol = protocol.replace(/\\:$/, '');\n\n  var getter = exports.protocols[protocol];\n\n  if ('function' != typeof getter)\n    return fn(new TypeError('unsupported protocol \"' + protocol + '\" specified in URI: ' + uri));\n\n  getter(parsed, opts || {}, fn);\n}\n"]},"metadata":{},"sourceType":"script"}