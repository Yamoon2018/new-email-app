{"ast":null,"code":"/* eslint no-undefined: 0 */\n'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar MimeNode = require('../mime-node');\n\nvar mimeFuncs = require('../mime-funcs');\n/**\n * Creates the object for composing a MimeNode instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\n\n\nvar MailComposer = /*#__PURE__*/function () {\n  function MailComposer(mail) {\n    _classCallCheck(this, MailComposer);\n\n    this.mail = mail || {};\n    this.message = false;\n  }\n  /**\n   * Builds MimeNode instance\n   */\n\n\n  _createClass(MailComposer, [{\n    key: \"compile\",\n    value: function compile() {\n      var _this = this;\n\n      this._alternatives = this.getAlternatives();\n      this._htmlNode = this._alternatives.filter(function (alternative) {\n        return /^text\\/html\\b/i.test(alternative.contentType);\n      }).pop();\n      this._attachments = this.getAttachments(!!this._htmlNode);\n      this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n      this._useAlternative = this._alternatives.length > 1;\n      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1; // Compose MIME tree\n\n      if (this.mail.raw) {\n        this.message = new MimeNode().setRaw(this.mail.raw);\n      } else if (this._useMixed) {\n        this.message = this._createMixed();\n      } else if (this._useAlternative) {\n        this.message = this._createAlternative();\n      } else if (this._useRelated) {\n        this.message = this._createRelated();\n      } else {\n        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {\n          contentType: 'text/plain',\n          content: ''\n        });\n      } // Add custom headers\n\n\n      if (this.mail.headers) {\n        this.message.addHeader(this.mail.headers);\n      } // Add headers to the root node, always overrides custom headers\n\n\n      ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(function (header) {\n        var key = header.replace(/-(\\w)/g, function (o, c) {\n          return c.toUpperCase();\n        });\n\n        if (_this.mail[key]) {\n          _this.message.setHeader(header, _this.mail[key]);\n        }\n      }); // Sets custom envelope\n\n      if (this.mail.envelope) {\n        this.message.setEnvelope(this.mail.envelope);\n      } // ensure Message-Id value\n\n\n      this.message.messageId();\n      return this.message;\n    }\n    /**\n     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes\n     *\n     * @param {Boolean} findRelated If true separate related attachments from attached ones\n     * @returns {Object} An object of arrays (`related` and `attached`)\n     */\n\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments(findRelated) {\n      var _this2 = this;\n\n      var icalEvent, eventObject;\n      var attachments = [].concat(this.mail.attachments || []).map(function (attachment, i) {\n        var data;\n        var isMessageNode = /^message\\//i.test(attachment.contentType);\n\n        if (/^data:/i.test(attachment.path || attachment.href)) {\n          attachment = _this2._processDataUrl(attachment);\n        }\n\n        data = {\n          contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),\n          contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),\n          contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'\n        };\n\n        if (attachment.filename) {\n          data.filename = attachment.filename;\n        } else if (!isMessageNode && attachment.filename !== false) {\n          data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n\n          if (data.filename.indexOf('.') < 0) {\n            data.filename += '.' + mimeFuncs.detectExtension(data.contentType);\n          }\n        }\n\n        if (/^https?:\\/\\//i.test(attachment.path)) {\n          attachment.href = attachment.path;\n          attachment.path = undefined;\n        }\n\n        if (attachment.cid) {\n          data.cid = attachment.cid;\n        }\n\n        if (attachment.raw) {\n          data.raw = attachment.raw;\n        } else if (attachment.path) {\n          data.content = {\n            path: attachment.path\n          };\n        } else if (attachment.href) {\n          data.content = {\n            href: attachment.href,\n            httpHeaders: attachment.httpHeaders\n          };\n        } else {\n          data.content = attachment.content || '';\n        }\n\n        if (attachment.encoding) {\n          data.encoding = attachment.encoding;\n        }\n\n        if (attachment.headers) {\n          data.headers = attachment.headers;\n        }\n\n        return data;\n      });\n\n      if (this.mail.icalEvent) {\n        if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n          icalEvent = this.mail.icalEvent;\n        } else {\n          icalEvent = {\n            content: this.mail.icalEvent\n          };\n        }\n\n        eventObject = {};\n        Object.keys(icalEvent).forEach(function (key) {\n          eventObject[key] = icalEvent[key];\n        });\n        eventObject.contentType = 'application/ics';\n\n        if (!eventObject.headers) {\n          eventObject.headers = {};\n        }\n\n        eventObject.filename = eventObject.filename || 'invite.ics';\n        eventObject.headers['Content-Disposition'] = 'attachment';\n        eventObject.headers['Content-Transfer-Encoding'] = 'base64';\n      }\n\n      if (!findRelated) {\n        return {\n          attached: attachments.concat(eventObject || []),\n          related: []\n        };\n      } else {\n        return {\n          attached: attachments.filter(function (attachment) {\n            return !attachment.cid;\n          }).concat(eventObject || []),\n          related: attachments.filter(function (attachment) {\n            return !!attachment.cid;\n          })\n        };\n      }\n    }\n    /**\n     * List alternatives. Resulting objects can be used as input for MimeNode nodes\n     *\n     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n     */\n\n  }, {\n    key: \"getAlternatives\",\n    value: function getAlternatives() {\n      var _this3 = this;\n\n      var alternatives = [],\n          text,\n          html,\n          watchHtml,\n          amp,\n          icalEvent,\n          eventObject;\n\n      if (this.mail.text) {\n        if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n          text = this.mail.text;\n        } else {\n          text = {\n            content: this.mail.text\n          };\n        }\n\n        text.contentType = 'text/plain; charset=utf-8';\n      }\n\n      if (this.mail.watchHtml) {\n        if (typeof this.mail.watchHtml === 'object' && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {\n          watchHtml = this.mail.watchHtml;\n        } else {\n          watchHtml = {\n            content: this.mail.watchHtml\n          };\n        }\n\n        watchHtml.contentType = 'text/watch-html; charset=utf-8';\n      }\n\n      if (this.mail.amp) {\n        if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {\n          amp = this.mail.amp;\n        } else {\n          amp = {\n            content: this.mail.amp\n          };\n        }\n\n        amp.contentType = 'text/x-amp-html; charset=utf-8';\n      } // only include the calendar alternative if there are no attachments\n      // otherwise you might end up in a blank screen on some clients\n\n\n      if (this.mail.icalEvent && !(this.mail.attachments && this.mail.attachments.length)) {\n        if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n          icalEvent = this.mail.icalEvent;\n        } else {\n          icalEvent = {\n            content: this.mail.icalEvent\n          };\n        }\n\n        eventObject = {};\n        Object.keys(icalEvent).forEach(function (key) {\n          eventObject[key] = icalEvent[key];\n        });\n\n        if (eventObject.content && typeof eventObject.content === 'object') {\n          // we are going to have the same attachment twice, so mark this to be\n          // resolved just once\n          eventObject.content._resolve = true;\n        }\n\n        eventObject.filename = false;\n        eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();\n\n        if (!eventObject.headers) {\n          eventObject.headers = {};\n        }\n      }\n\n      if (this.mail.html) {\n        if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n          html = this.mail.html;\n        } else {\n          html = {\n            content: this.mail.html\n          };\n        }\n\n        html.contentType = 'text/html; charset=utf-8';\n      }\n\n      [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach(function (alternative) {\n        var data;\n\n        if (/^data:/i.test(alternative.path || alternative.href)) {\n          alternative = _this3._processDataUrl(alternative);\n        }\n\n        data = {\n          contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n          contentTransferEncoding: alternative.contentTransferEncoding\n        };\n\n        if (alternative.filename) {\n          data.filename = alternative.filename;\n        }\n\n        if (/^https?:\\/\\//i.test(alternative.path)) {\n          alternative.href = alternative.path;\n          alternative.path = undefined;\n        }\n\n        if (alternative.raw) {\n          data.raw = alternative.raw;\n        } else if (alternative.path) {\n          data.content = {\n            path: alternative.path\n          };\n        } else if (alternative.href) {\n          data.content = {\n            href: alternative.href\n          };\n        } else {\n          data.content = alternative.content || '';\n        }\n\n        if (alternative.encoding) {\n          data.encoding = alternative.encoding;\n        }\n\n        if (alternative.headers) {\n          data.headers = alternative.headers;\n        }\n\n        alternatives.push(data);\n      });\n      return alternatives;\n    }\n    /**\n     * Builds multipart/mixed node. It should always contain different type of elements on the same level\n     * eg. text + attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createMixed\",\n    value: function _createMixed(parentNode) {\n      var _this4 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/mixed', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/mixed', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      if (this._useAlternative) {\n        this._createAlternative(node);\n      } else if (this._useRelated) {\n        this._createRelated(node);\n      }\n\n      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach(function (element) {\n        // if the element is a html node from related subpart then ignore it\n        if (!_this4._useRelated || element !== _this4._htmlNode) {\n          _this4._createContentNode(node, element);\n        }\n      });\n      return node;\n    }\n    /**\n     * Builds multipart/alternative node. It should always contain same type of elements on the same level\n     * eg. text + html view of the same data\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createAlternative\",\n    value: function _createAlternative(parentNode) {\n      var _this5 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/alternative', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/alternative', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      this._alternatives.forEach(function (alternative) {\n        if (_this5._useRelated && _this5._htmlNode === alternative) {\n          _this5._createRelated(node);\n        } else {\n          _this5._createContentNode(node, alternative);\n        }\n      });\n\n      return node;\n    }\n    /**\n     * Builds multipart/related node. It should always contain html node with related attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createRelated\",\n    value: function _createRelated(parentNode) {\n      var _this6 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/related; type=\"text/html\"', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      this._createContentNode(node, this._htmlNode);\n\n      this._attachments.related.forEach(function (alternative) {\n        return _this6._createContentNode(node, alternative);\n      });\n\n      return node;\n    }\n    /**\n     * Creates a regular node with contents\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @param {Object} element Node data\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createContentNode\",\n    value: function _createContentNode(parentNode, element) {\n      element = element || {};\n      element.content = element.content || '';\n      var node;\n      var encoding = (element.encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n      if (!parentNode) {\n        node = new MimeNode(element.contentType, {\n          filename: element.filename,\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild(element.contentType, {\n          filename: element.filename,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } // add custom headers\n\n\n      if (element.headers) {\n        node.addHeader(element.headers);\n      }\n\n      if (element.cid) {\n        node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n      }\n\n      if (element.contentTransferEncoding) {\n        node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n      } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n        node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n      }\n\n      if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n        node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));\n      }\n\n      if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        element.content = Buffer.from(element.content, encoding);\n      } // prefer pregenerated raw content\n\n\n      if (element.raw) {\n        node.setRaw(element.raw);\n      } else {\n        node.setContent(element.content);\n      }\n\n      return node;\n    }\n    /**\n     * Parses data uri and converts it to a Buffer\n     *\n     * @param {Object} element Content element\n     * @return {Object} Parsed element\n     */\n\n  }, {\n    key: \"_processDataUrl\",\n    value: function _processDataUrl(element) {\n      var parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return element;\n      }\n\n      element.content = /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2]));\n\n      if ('path' in element) {\n        element.path = false;\n      }\n\n      if ('href' in element) {\n        element.href = false;\n      }\n\n      parts[1].split(';').forEach(function (item) {\n        if (/^\\w+\\/[^/]+$/i.test(item)) {\n          element.contentType = element.contentType || item.toLowerCase();\n        }\n      });\n      return element;\n    }\n  }]);\n\n  return MailComposer;\n}();\n\nmodule.exports = MailComposer;","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/mail-composer/index.js"],"names":["MimeNode","require","mimeFuncs","MailComposer","mail","message","_alternatives","getAlternatives","_htmlNode","filter","alternative","test","contentType","pop","_attachments","getAttachments","_useRelated","related","length","_useAlternative","_useMixed","attached","raw","setRaw","_createMixed","_createAlternative","_createRelated","_createContentNode","concat","shift","content","headers","addHeader","forEach","header","key","replace","o","c","toUpperCase","setHeader","envelope","setEnvelope","messageId","findRelated","icalEvent","eventObject","attachments","map","attachment","i","data","isMessageNode","path","href","_processDataUrl","detectMimeType","filename","contentDisposition","contentTransferEncoding","split","indexOf","detectExtension","undefined","cid","httpHeaders","encoding","Object","keys","alternatives","text","html","watchHtml","amp","_resolve","method","toString","trim","push","parentNode","node","baseBoundary","textEncoding","boundaryPrefix","disableUrlAccess","disableFileAccess","normalizeHeaderKey","createChild","element","toLowerCase","includes","Buffer","from","setContent","parts","match","decodeURIComponent","item","module","exports"],"mappings":"AAAA;AAEA;;;;;;AAEA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,eAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;;;IACME,Y;AACF,wBAAYC,IAAZ,EAAkB;AAAA;;AACd,SAAKA,IAAL,GAAYA,IAAI,IAAI,EAApB;AACA,SAAKC,OAAL,GAAe,KAAf;AACH;AAED;AACJ;AACA;;;;;8BACc;AAAA;;AACN,WAAKC,aAAL,GAAqB,KAAKC,eAAL,EAArB;AACA,WAAKC,SAAL,GAAiB,KAAKF,aAAL,CAAmBG,MAAnB,CAA0B,UAAAC,WAAW;AAAA,eAAI,iBAAiBC,IAAjB,CAAsBD,WAAW,CAACE,WAAlC,CAAJ;AAAA,OAArC,EAAyFC,GAAzF,EAAjB;AACA,WAAKC,YAAL,GAAoB,KAAKC,cAAL,CAAoB,CAAC,CAAC,KAAKP,SAA3B,CAApB;AAEA,WAAKQ,WAAL,GAAmB,CAAC,EAAE,KAAKR,SAAL,IAAkB,KAAKM,YAAL,CAAkBG,OAAlB,CAA0BC,MAA9C,CAApB;AACA,WAAKC,eAAL,GAAuB,KAAKb,aAAL,CAAmBY,MAAnB,GAA4B,CAAnD;AACA,WAAKE,SAAL,GAAiB,KAAKN,YAAL,CAAkBO,QAAlB,CAA2BH,MAA3B,GAAoC,CAApC,IAA0C,KAAKZ,aAAL,CAAmBY,MAAnB,IAA6B,KAAKJ,YAAL,CAAkBO,QAAlB,CAA2BH,MAA3B,KAAsC,CAA9H,CAPM,CASN;;AACA,UAAI,KAAKd,IAAL,CAAUkB,GAAd,EAAmB;AACf,aAAKjB,OAAL,GAAe,IAAIL,QAAJ,GAAeuB,MAAf,CAAsB,KAAKnB,IAAL,CAAUkB,GAAhC,CAAf;AACH,OAFD,MAEO,IAAI,KAAKF,SAAT,EAAoB;AACvB,aAAKf,OAAL,GAAe,KAAKmB,YAAL,EAAf;AACH,OAFM,MAEA,IAAI,KAAKL,eAAT,EAA0B;AAC7B,aAAKd,OAAL,GAAe,KAAKoB,kBAAL,EAAf;AACH,OAFM,MAEA,IAAI,KAAKT,WAAT,EAAsB;AACzB,aAAKX,OAAL,GAAe,KAAKqB,cAAL,EAAf;AACH,OAFM,MAEA;AACH,aAAKrB,OAAL,GAAe,KAAKsB,kBAAL,CACX,KADW,EAEX,GACKC,MADL,CACY,KAAKtB,aAAL,IAAsB,EADlC,EAEKsB,MAFL,CAEY,KAAKd,YAAL,CAAkBO,QAAlB,IAA8B,EAF1C,EAGKQ,KAHL,MAGgB;AACZjB,UAAAA,WAAW,EAAE,YADD;AAEZkB,UAAAA,OAAO,EAAE;AAFG,SALL,CAAf;AAUH,OA7BK,CA+BN;;;AACA,UAAI,KAAK1B,IAAL,CAAU2B,OAAd,EAAuB;AACnB,aAAK1B,OAAL,CAAa2B,SAAb,CAAuB,KAAK5B,IAAL,CAAU2B,OAAjC;AACH,OAlCK,CAoCN;;;AACA,OAAC,MAAD,EAAS,QAAT,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,KAA/B,EAAsC,UAAtC,EAAkD,aAAlD,EAAiE,YAAjE,EAA+E,SAA/E,EAA0F,YAA1F,EAAwG,MAAxG,EAAgHE,OAAhH,CAAwH,UAAAC,MAAM,EAAI;AAC9H,YAAIC,GAAG,GAAGD,MAAM,CAACE,OAAP,CAAe,QAAf,EAAyB,UAACC,CAAD,EAAIC,CAAJ;AAAA,iBAAUA,CAAC,CAACC,WAAF,EAAV;AAAA,SAAzB,CAAV;;AACA,YAAI,KAAI,CAACnC,IAAL,CAAU+B,GAAV,CAAJ,EAAoB;AAChB,UAAA,KAAI,CAAC9B,OAAL,CAAamC,SAAb,CAAuBN,MAAvB,EAA+B,KAAI,CAAC9B,IAAL,CAAU+B,GAAV,CAA/B;AACH;AACJ,OALD,EArCM,CA4CN;;AACA,UAAI,KAAK/B,IAAL,CAAUqC,QAAd,EAAwB;AACpB,aAAKpC,OAAL,CAAaqC,WAAb,CAAyB,KAAKtC,IAAL,CAAUqC,QAAnC;AACH,OA/CK,CAiDN;;;AACA,WAAKpC,OAAL,CAAasC,SAAb;AAEA,aAAO,KAAKtC,OAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;mCACmBuC,W,EAAa;AAAA;;AACxB,UAAIC,SAAJ,EAAeC,WAAf;AACA,UAAIC,WAAW,GAAG,GAAGnB,MAAH,CAAU,KAAKxB,IAAL,CAAU2C,WAAV,IAAyB,EAAnC,EAAuCC,GAAvC,CAA2C,UAACC,UAAD,EAAaC,CAAb,EAAmB;AAC5E,YAAIC,IAAJ;AACA,YAAIC,aAAa,GAAG,cAAczC,IAAd,CAAmBsC,UAAU,CAACrC,WAA9B,CAApB;;AAEA,YAAI,UAAUD,IAAV,CAAesC,UAAU,CAACI,IAAX,IAAmBJ,UAAU,CAACK,IAA7C,CAAJ,EAAwD;AACpDL,UAAAA,UAAU,GAAG,MAAI,CAACM,eAAL,CAAqBN,UAArB,CAAb;AACH;;AAEDE,QAAAA,IAAI,GAAG;AACHvC,UAAAA,WAAW,EAAEqC,UAAU,CAACrC,WAAX,IAA0BV,SAAS,CAACsD,cAAV,CAAyBP,UAAU,CAACQ,QAAX,IAAuBR,UAAU,CAACI,IAAlC,IAA0CJ,UAAU,CAACK,IAArD,IAA6D,KAAtF,CADpC;AAEHI,UAAAA,kBAAkB,EAAET,UAAU,CAACS,kBAAX,KAAkCN,aAAa,GAAG,QAAH,GAAc,YAA7D,CAFjB;AAGHO,UAAAA,uBAAuB,EAAE,6BAA6BV,UAA7B,GAA0CA,UAAU,CAACU,uBAArD,GAA+E;AAHrG,SAAP;;AAMA,YAAIV,UAAU,CAACQ,QAAf,EAAyB;AACrBN,UAAAA,IAAI,CAACM,QAAL,GAAgBR,UAAU,CAACQ,QAA3B;AACH,SAFD,MAEO,IAAI,CAACL,aAAD,IAAkBH,UAAU,CAACQ,QAAX,KAAwB,KAA9C,EAAqD;AACxDN,UAAAA,IAAI,CAACM,QAAL,GAAgB,CAACR,UAAU,CAACI,IAAX,IAAmBJ,UAAU,CAACK,IAA9B,IAAsC,EAAvC,EAA2CM,KAA3C,CAAiD,GAAjD,EAAsD/C,GAAtD,GAA4D+C,KAA5D,CAAkE,GAAlE,EAAuE/B,KAAvE,MAAkF,iBAAiBqB,CAAC,GAAG,CAArB,CAAlG;;AACA,cAAIC,IAAI,CAACM,QAAL,CAAcI,OAAd,CAAsB,GAAtB,IAA6B,CAAjC,EAAoC;AAChCV,YAAAA,IAAI,CAACM,QAAL,IAAiB,MAAMvD,SAAS,CAAC4D,eAAV,CAA0BX,IAAI,CAACvC,WAA/B,CAAvB;AACH;AACJ;;AAED,YAAI,gBAAgBD,IAAhB,CAAqBsC,UAAU,CAACI,IAAhC,CAAJ,EAA2C;AACvCJ,UAAAA,UAAU,CAACK,IAAX,GAAkBL,UAAU,CAACI,IAA7B;AACAJ,UAAAA,UAAU,CAACI,IAAX,GAAkBU,SAAlB;AACH;;AAED,YAAId,UAAU,CAACe,GAAf,EAAoB;AAChBb,UAAAA,IAAI,CAACa,GAAL,GAAWf,UAAU,CAACe,GAAtB;AACH;;AAED,YAAIf,UAAU,CAAC3B,GAAf,EAAoB;AAChB6B,UAAAA,IAAI,CAAC7B,GAAL,GAAW2B,UAAU,CAAC3B,GAAtB;AACH,SAFD,MAEO,IAAI2B,UAAU,CAACI,IAAf,EAAqB;AACxBF,UAAAA,IAAI,CAACrB,OAAL,GAAe;AACXuB,YAAAA,IAAI,EAAEJ,UAAU,CAACI;AADN,WAAf;AAGH,SAJM,MAIA,IAAIJ,UAAU,CAACK,IAAf,EAAqB;AACxBH,UAAAA,IAAI,CAACrB,OAAL,GAAe;AACXwB,YAAAA,IAAI,EAAEL,UAAU,CAACK,IADN;AAEXW,YAAAA,WAAW,EAAEhB,UAAU,CAACgB;AAFb,WAAf;AAIH,SALM,MAKA;AACHd,UAAAA,IAAI,CAACrB,OAAL,GAAemB,UAAU,CAACnB,OAAX,IAAsB,EAArC;AACH;;AAED,YAAImB,UAAU,CAACiB,QAAf,EAAyB;AACrBf,UAAAA,IAAI,CAACe,QAAL,GAAgBjB,UAAU,CAACiB,QAA3B;AACH;;AAED,YAAIjB,UAAU,CAAClB,OAAf,EAAwB;AACpBoB,UAAAA,IAAI,CAACpB,OAAL,GAAekB,UAAU,CAAClB,OAA1B;AACH;;AAED,eAAOoB,IAAP;AACH,OAxDiB,CAAlB;;AA0DA,UAAI,KAAK/C,IAAL,CAAUyC,SAAd,EAAyB;AACrB,YACI,OAAO,KAAKzC,IAAL,CAAUyC,SAAjB,KAA+B,QAA/B,KACC,KAAKzC,IAAL,CAAUyC,SAAV,CAAoBf,OAApB,IAA+B,KAAK1B,IAAL,CAAUyC,SAAV,CAAoBQ,IAAnD,IAA2D,KAAKjD,IAAL,CAAUyC,SAAV,CAAoBS,IAA/E,IAAuF,KAAKlD,IAAL,CAAUyC,SAAV,CAAoBvB,GAD5G,CADJ,EAGE;AACEuB,UAAAA,SAAS,GAAG,KAAKzC,IAAL,CAAUyC,SAAtB;AACH,SALD,MAKO;AACHA,UAAAA,SAAS,GAAG;AACRf,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUyC;AADX,WAAZ;AAGH;;AAEDC,QAAAA,WAAW,GAAG,EAAd;AACAqB,QAAAA,MAAM,CAACC,IAAP,CAAYvB,SAAZ,EAAuBZ,OAAvB,CAA+B,UAAAE,GAAG,EAAI;AAClCW,UAAAA,WAAW,CAACX,GAAD,CAAX,GAAmBU,SAAS,CAACV,GAAD,CAA5B;AACH,SAFD;AAIAW,QAAAA,WAAW,CAAClC,WAAZ,GAA0B,iBAA1B;;AACA,YAAI,CAACkC,WAAW,CAACf,OAAjB,EAA0B;AACtBe,UAAAA,WAAW,CAACf,OAAZ,GAAsB,EAAtB;AACH;;AACDe,QAAAA,WAAW,CAACW,QAAZ,GAAuBX,WAAW,CAACW,QAAZ,IAAwB,YAA/C;AACAX,QAAAA,WAAW,CAACf,OAAZ,CAAoB,qBAApB,IAA6C,YAA7C;AACAe,QAAAA,WAAW,CAACf,OAAZ,CAAoB,2BAApB,IAAmD,QAAnD;AACH;;AAED,UAAI,CAACa,WAAL,EAAkB;AACd,eAAO;AACHvB,UAAAA,QAAQ,EAAE0B,WAAW,CAACnB,MAAZ,CAAmBkB,WAAW,IAAI,EAAlC,CADP;AAEH7B,UAAAA,OAAO,EAAE;AAFN,SAAP;AAIH,OALD,MAKO;AACH,eAAO;AACHI,UAAAA,QAAQ,EAAE0B,WAAW,CAACtC,MAAZ,CAAmB,UAAAwC,UAAU;AAAA,mBAAI,CAACA,UAAU,CAACe,GAAhB;AAAA,WAA7B,EAAkDpC,MAAlD,CAAyDkB,WAAW,IAAI,EAAxE,CADP;AAEH7B,UAAAA,OAAO,EAAE8B,WAAW,CAACtC,MAAZ,CAAmB,UAAAwC,UAAU;AAAA,mBAAI,CAAC,CAACA,UAAU,CAACe,GAAjB;AAAA,WAA7B;AAFN,SAAP;AAIH;AACJ;AAED;AACJ;AACA;AACA;AACA;;;;sCACsB;AAAA;;AACd,UAAIK,YAAY,GAAG,EAAnB;AAAA,UACIC,IADJ;AAAA,UAEIC,IAFJ;AAAA,UAGIC,SAHJ;AAAA,UAIIC,GAJJ;AAAA,UAKI5B,SALJ;AAAA,UAMIC,WANJ;;AAQA,UAAI,KAAK1C,IAAL,CAAUkE,IAAd,EAAoB;AAChB,YAAI,OAAO,KAAKlE,IAAL,CAAUkE,IAAjB,KAA0B,QAA1B,KAAuC,KAAKlE,IAAL,CAAUkE,IAAV,CAAexC,OAAf,IAA0B,KAAK1B,IAAL,CAAUkE,IAAV,CAAejB,IAAzC,IAAiD,KAAKjD,IAAL,CAAUkE,IAAV,CAAehB,IAAhE,IAAwE,KAAKlD,IAAL,CAAUkE,IAAV,CAAehD,GAA9H,CAAJ,EAAwI;AACpIgD,UAAAA,IAAI,GAAG,KAAKlE,IAAL,CAAUkE,IAAjB;AACH,SAFD,MAEO;AACHA,UAAAA,IAAI,GAAG;AACHxC,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUkE;AADhB,WAAP;AAGH;;AACDA,QAAAA,IAAI,CAAC1D,WAAL,GAAmB,2BAAnB;AACH;;AAED,UAAI,KAAKR,IAAL,CAAUoE,SAAd,EAAyB;AACrB,YACI,OAAO,KAAKpE,IAAL,CAAUoE,SAAjB,KAA+B,QAA/B,KACC,KAAKpE,IAAL,CAAUoE,SAAV,CAAoB1C,OAApB,IAA+B,KAAK1B,IAAL,CAAUoE,SAAV,CAAoBnB,IAAnD,IAA2D,KAAKjD,IAAL,CAAUoE,SAAV,CAAoBlB,IAA/E,IAAuF,KAAKlD,IAAL,CAAUoE,SAAV,CAAoBlD,GAD5G,CADJ,EAGE;AACEkD,UAAAA,SAAS,GAAG,KAAKpE,IAAL,CAAUoE,SAAtB;AACH,SALD,MAKO;AACHA,UAAAA,SAAS,GAAG;AACR1C,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUoE;AADX,WAAZ;AAGH;;AACDA,QAAAA,SAAS,CAAC5D,WAAV,GAAwB,gCAAxB;AACH;;AAED,UAAI,KAAKR,IAAL,CAAUqE,GAAd,EAAmB;AACf,YAAI,OAAO,KAAKrE,IAAL,CAAUqE,GAAjB,KAAyB,QAAzB,KAAsC,KAAKrE,IAAL,CAAUqE,GAAV,CAAc3C,OAAd,IAAyB,KAAK1B,IAAL,CAAUqE,GAAV,CAAcpB,IAAvC,IAA+C,KAAKjD,IAAL,CAAUqE,GAAV,CAAcnB,IAA7D,IAAqE,KAAKlD,IAAL,CAAUqE,GAAV,CAAcnD,GAAzH,CAAJ,EAAmI;AAC/HmD,UAAAA,GAAG,GAAG,KAAKrE,IAAL,CAAUqE,GAAhB;AACH,SAFD,MAEO;AACHA,UAAAA,GAAG,GAAG;AACF3C,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUqE;AADjB,WAAN;AAGH;;AACDA,QAAAA,GAAG,CAAC7D,WAAJ,GAAkB,gCAAlB;AACH,OA3Ca,CA6Cd;AACA;;;AACA,UAAI,KAAKR,IAAL,CAAUyC,SAAV,IAAuB,EAAE,KAAKzC,IAAL,CAAU2C,WAAV,IAAyB,KAAK3C,IAAL,CAAU2C,WAAV,CAAsB7B,MAAjD,CAA3B,EAAqF;AACjF,YACI,OAAO,KAAKd,IAAL,CAAUyC,SAAjB,KAA+B,QAA/B,KACC,KAAKzC,IAAL,CAAUyC,SAAV,CAAoBf,OAApB,IAA+B,KAAK1B,IAAL,CAAUyC,SAAV,CAAoBQ,IAAnD,IAA2D,KAAKjD,IAAL,CAAUyC,SAAV,CAAoBS,IAA/E,IAAuF,KAAKlD,IAAL,CAAUyC,SAAV,CAAoBvB,GAD5G,CADJ,EAGE;AACEuB,UAAAA,SAAS,GAAG,KAAKzC,IAAL,CAAUyC,SAAtB;AACH,SALD,MAKO;AACHA,UAAAA,SAAS,GAAG;AACRf,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUyC;AADX,WAAZ;AAGH;;AAEDC,QAAAA,WAAW,GAAG,EAAd;AACAqB,QAAAA,MAAM,CAACC,IAAP,CAAYvB,SAAZ,EAAuBZ,OAAvB,CAA+B,UAAAE,GAAG,EAAI;AAClCW,UAAAA,WAAW,CAACX,GAAD,CAAX,GAAmBU,SAAS,CAACV,GAAD,CAA5B;AACH,SAFD;;AAIA,YAAIW,WAAW,CAAChB,OAAZ,IAAuB,OAAOgB,WAAW,CAAChB,OAAnB,KAA+B,QAA1D,EAAoE;AAChE;AACA;AACAgB,UAAAA,WAAW,CAAChB,OAAZ,CAAoB4C,QAApB,GAA+B,IAA/B;AACH;;AAED5B,QAAAA,WAAW,CAACW,QAAZ,GAAuB,KAAvB;AACAX,QAAAA,WAAW,CAAClC,WAAZ,GAA0B,0CAA0C,CAACkC,WAAW,CAAC6B,MAAZ,IAAsB,SAAvB,EAAkCC,QAAlC,GAA6CC,IAA7C,GAAoDtC,WAApD,EAApE;;AACA,YAAI,CAACO,WAAW,CAACf,OAAjB,EAA0B;AACtBe,UAAAA,WAAW,CAACf,OAAZ,GAAsB,EAAtB;AACH;AACJ;;AAED,UAAI,KAAK3B,IAAL,CAAUmE,IAAd,EAAoB;AAChB,YAAI,OAAO,KAAKnE,IAAL,CAAUmE,IAAjB,KAA0B,QAA1B,KAAuC,KAAKnE,IAAL,CAAUmE,IAAV,CAAezC,OAAf,IAA0B,KAAK1B,IAAL,CAAUmE,IAAV,CAAelB,IAAzC,IAAiD,KAAKjD,IAAL,CAAUmE,IAAV,CAAejB,IAAhE,IAAwE,KAAKlD,IAAL,CAAUmE,IAAV,CAAejD,GAA9H,CAAJ,EAAwI;AACpIiD,UAAAA,IAAI,GAAG,KAAKnE,IAAL,CAAUmE,IAAjB;AACH,SAFD,MAEO;AACHA,UAAAA,IAAI,GAAG;AACHzC,YAAAA,OAAO,EAAE,KAAK1B,IAAL,CAAUmE;AADhB,WAAP;AAGH;;AACDA,QAAAA,IAAI,CAAC3D,WAAL,GAAmB,0BAAnB;AACH;;AAED,SACKgB,MADL,CACY0C,IAAI,IAAI,EADpB,EAEK1C,MAFL,CAEY4C,SAAS,IAAI,EAFzB,EAGK5C,MAHL,CAGY6C,GAAG,IAAI,EAHnB,EAIK7C,MAJL,CAIY2C,IAAI,IAAI,EAJpB,EAKK3C,MALL,CAKYkB,WAAW,IAAI,EAL3B,EAMKlB,MANL,CAMY,KAAKxB,IAAL,CAAUiE,YAAV,IAA0B,EANtC,EAOKpC,OAPL,CAOa,UAAAvB,WAAW,EAAI;AACpB,YAAIyC,IAAJ;;AAEA,YAAI,UAAUxC,IAAV,CAAeD,WAAW,CAAC2C,IAAZ,IAAoB3C,WAAW,CAAC4C,IAA/C,CAAJ,EAA0D;AACtD5C,UAAAA,WAAW,GAAG,MAAI,CAAC6C,eAAL,CAAqB7C,WAArB,CAAd;AACH;;AAEDyC,QAAAA,IAAI,GAAG;AACHvC,UAAAA,WAAW,EAAEF,WAAW,CAACE,WAAZ,IAA2BV,SAAS,CAACsD,cAAV,CAAyB9C,WAAW,CAAC+C,QAAZ,IAAwB/C,WAAW,CAAC2C,IAApC,IAA4C3C,WAAW,CAAC4C,IAAxD,IAAgE,KAAzF,CADrC;AAEHK,UAAAA,uBAAuB,EAAEjD,WAAW,CAACiD;AAFlC,SAAP;;AAKA,YAAIjD,WAAW,CAAC+C,QAAhB,EAA0B;AACtBN,UAAAA,IAAI,CAACM,QAAL,GAAgB/C,WAAW,CAAC+C,QAA5B;AACH;;AAED,YAAI,gBAAgB9C,IAAhB,CAAqBD,WAAW,CAAC2C,IAAjC,CAAJ,EAA4C;AACxC3C,UAAAA,WAAW,CAAC4C,IAAZ,GAAmB5C,WAAW,CAAC2C,IAA/B;AACA3C,UAAAA,WAAW,CAAC2C,IAAZ,GAAmBU,SAAnB;AACH;;AAED,YAAIrD,WAAW,CAACY,GAAhB,EAAqB;AACjB6B,UAAAA,IAAI,CAAC7B,GAAL,GAAWZ,WAAW,CAACY,GAAvB;AACH,SAFD,MAEO,IAAIZ,WAAW,CAAC2C,IAAhB,EAAsB;AACzBF,UAAAA,IAAI,CAACrB,OAAL,GAAe;AACXuB,YAAAA,IAAI,EAAE3C,WAAW,CAAC2C;AADP,WAAf;AAGH,SAJM,MAIA,IAAI3C,WAAW,CAAC4C,IAAhB,EAAsB;AACzBH,UAAAA,IAAI,CAACrB,OAAL,GAAe;AACXwB,YAAAA,IAAI,EAAE5C,WAAW,CAAC4C;AADP,WAAf;AAGH,SAJM,MAIA;AACHH,UAAAA,IAAI,CAACrB,OAAL,GAAepB,WAAW,CAACoB,OAAZ,IAAuB,EAAtC;AACH;;AAED,YAAIpB,WAAW,CAACwD,QAAhB,EAA0B;AACtBf,UAAAA,IAAI,CAACe,QAAL,GAAgBxD,WAAW,CAACwD,QAA5B;AACH;;AAED,YAAIxD,WAAW,CAACqB,OAAhB,EAAyB;AACrBoB,UAAAA,IAAI,CAACpB,OAAL,GAAerB,WAAW,CAACqB,OAA3B;AACH;;AAEDsC,QAAAA,YAAY,CAACS,IAAb,CAAkB3B,IAAlB;AACH,OAnDL;AAqDA,aAAOkB,YAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;iCACiBU,U,EAAY;AAAA;;AACrB,UAAIC,IAAJ;;AAEA,UAAI,CAACD,UAAL,EAAiB;AACbC,QAAAA,IAAI,GAAG,IAAIhF,QAAJ,CAAa,iBAAb,EAAgC;AACnCiF,UAAAA,YAAY,EAAE,KAAK7E,IAAL,CAAU6E,YADW;AAEnCC,UAAAA,YAAY,EAAE,KAAK9E,IAAL,CAAU8E,YAFW;AAGnCC,UAAAA,cAAc,EAAE,KAAK/E,IAAL,CAAU+E,cAHS;AAInCC,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBAJO;AAKnCC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBALM;AAMnCC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AANK,SAAhC,CAAP;AAQH,OATD,MASO;AACHN,QAAAA,IAAI,GAAGD,UAAU,CAACQ,WAAX,CAAuB,iBAAvB,EAA0C;AAC7CH,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBADiB;AAE7CC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBAFgB;AAG7CC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AAHe,SAA1C,CAAP;AAKH;;AAED,UAAI,KAAKnE,eAAT,EAA0B;AACtB,aAAKM,kBAAL,CAAwBuD,IAAxB;AACH,OAFD,MAEO,IAAI,KAAKhE,WAAT,EAAsB;AACzB,aAAKU,cAAL,CAAoBsD,IAApB;AACH;;AAED,SACKpD,MADL,CACa,CAAC,KAAKT,eAAN,IAAyB,KAAKb,aAA/B,IAAiD,EAD7D,EAEKsB,MAFL,CAEY,KAAKd,YAAL,CAAkBO,QAAlB,IAA8B,EAF1C,EAGKY,OAHL,CAGa,UAAAuD,OAAO,EAAI;AAChB;AACA,YAAI,CAAC,MAAI,CAACxE,WAAN,IAAqBwE,OAAO,KAAK,MAAI,CAAChF,SAA1C,EAAqD;AACjD,UAAA,MAAI,CAACmB,kBAAL,CAAwBqD,IAAxB,EAA8BQ,OAA9B;AACH;AACJ,OARL;AAUA,aAAOR,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;uCACuBD,U,EAAY;AAAA;;AAC3B,UAAIC,IAAJ;;AAEA,UAAI,CAACD,UAAL,EAAiB;AACbC,QAAAA,IAAI,GAAG,IAAIhF,QAAJ,CAAa,uBAAb,EAAsC;AACzCiF,UAAAA,YAAY,EAAE,KAAK7E,IAAL,CAAU6E,YADiB;AAEzCC,UAAAA,YAAY,EAAE,KAAK9E,IAAL,CAAU8E,YAFiB;AAGzCC,UAAAA,cAAc,EAAE,KAAK/E,IAAL,CAAU+E,cAHe;AAIzCC,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBAJa;AAKzCC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBALY;AAMzCC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AANW,SAAtC,CAAP;AAQH,OATD,MASO;AACHN,QAAAA,IAAI,GAAGD,UAAU,CAACQ,WAAX,CAAuB,uBAAvB,EAAgD;AACnDH,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBADuB;AAEnDC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBAFsB;AAGnDC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AAHqB,SAAhD,CAAP;AAKH;;AAED,WAAKhF,aAAL,CAAmB2B,OAAnB,CAA2B,UAAAvB,WAAW,EAAI;AACtC,YAAI,MAAI,CAACM,WAAL,IAAoB,MAAI,CAACR,SAAL,KAAmBE,WAA3C,EAAwD;AACpD,UAAA,MAAI,CAACgB,cAAL,CAAoBsD,IAApB;AACH,SAFD,MAEO;AACH,UAAA,MAAI,CAACrD,kBAAL,CAAwBqD,IAAxB,EAA8BtE,WAA9B;AACH;AACJ,OAND;;AAQA,aAAOsE,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;mCACmBD,U,EAAY;AAAA;;AACvB,UAAIC,IAAJ;;AAEA,UAAI,CAACD,UAAL,EAAiB;AACbC,QAAAA,IAAI,GAAG,IAAIhF,QAAJ,CAAa,qCAAb,EAAoD;AACvDiF,UAAAA,YAAY,EAAE,KAAK7E,IAAL,CAAU6E,YAD+B;AAEvDC,UAAAA,YAAY,EAAE,KAAK9E,IAAL,CAAU8E,YAF+B;AAGvDC,UAAAA,cAAc,EAAE,KAAK/E,IAAL,CAAU+E,cAH6B;AAIvDC,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBAJ2B;AAKvDC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBAL0B;AAMvDC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AANyB,SAApD,CAAP;AAQH,OATD,MASO;AACHN,QAAAA,IAAI,GAAGD,UAAU,CAACQ,WAAX,CAAuB,qCAAvB,EAA8D;AACjEH,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBADqC;AAEjEC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBAFoC;AAGjEC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AAHmC,SAA9D,CAAP;AAKH;;AAED,WAAK3D,kBAAL,CAAwBqD,IAAxB,EAA8B,KAAKxE,SAAnC;;AAEA,WAAKM,YAAL,CAAkBG,OAAlB,CAA0BgB,OAA1B,CAAkC,UAAAvB,WAAW;AAAA,eAAI,MAAI,CAACiB,kBAAL,CAAwBqD,IAAxB,EAA8BtE,WAA9B,CAAJ;AAAA,OAA7C;;AAEA,aAAOsE,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;;uCACuBD,U,EAAYS,O,EAAS;AACpCA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,MAAAA,OAAO,CAAC1D,OAAR,GAAkB0D,OAAO,CAAC1D,OAAR,IAAmB,EAArC;AAEA,UAAIkD,IAAJ;AACA,UAAId,QAAQ,GAAG,CAACsB,OAAO,CAACtB,QAAR,IAAoB,MAArB,EACVU,QADU,GAEVa,WAFU,GAGVrD,OAHU,CAGF,SAHE,EAGS,EAHT,CAAf;;AAKA,UAAI,CAAC2C,UAAL,EAAiB;AACbC,QAAAA,IAAI,GAAG,IAAIhF,QAAJ,CAAawF,OAAO,CAAC5E,WAArB,EAAkC;AACrC6C,UAAAA,QAAQ,EAAE+B,OAAO,CAAC/B,QADmB;AAErCwB,UAAAA,YAAY,EAAE,KAAK7E,IAAL,CAAU6E,YAFa;AAGrCC,UAAAA,YAAY,EAAE,KAAK9E,IAAL,CAAU8E,YAHa;AAIrCC,UAAAA,cAAc,EAAE,KAAK/E,IAAL,CAAU+E,cAJW;AAKrCC,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBALS;AAMrCC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBANQ;AAOrCC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AAPO,SAAlC,CAAP;AASH,OAVD,MAUO;AACHN,QAAAA,IAAI,GAAGD,UAAU,CAACQ,WAAX,CAAuBC,OAAO,CAAC5E,WAA/B,EAA4C;AAC/C6C,UAAAA,QAAQ,EAAE+B,OAAO,CAAC/B,QAD6B;AAE/C2B,UAAAA,gBAAgB,EAAE,KAAKhF,IAAL,CAAUgF,gBAFmB;AAG/CC,UAAAA,iBAAiB,EAAE,KAAKjF,IAAL,CAAUiF,iBAHkB;AAI/CC,UAAAA,kBAAkB,EAAE,KAAKlF,IAAL,CAAUkF;AAJiB,SAA5C,CAAP;AAMH,OA3BmC,CA6BpC;;;AACA,UAAIE,OAAO,CAACzD,OAAZ,EAAqB;AACjBiD,QAAAA,IAAI,CAAChD,SAAL,CAAewD,OAAO,CAACzD,OAAvB;AACH;;AAED,UAAIyD,OAAO,CAACxB,GAAZ,EAAiB;AACbgB,QAAAA,IAAI,CAACxC,SAAL,CAAe,YAAf,EAA6B,MAAMgD,OAAO,CAACxB,GAAR,CAAY5B,OAAZ,CAAoB,OAApB,EAA6B,EAA7B,CAAN,GAAyC,GAAtE;AACH;;AAED,UAAIoD,OAAO,CAAC7B,uBAAZ,EAAqC;AACjCqB,QAAAA,IAAI,CAACxC,SAAL,CAAe,2BAAf,EAA4CgD,OAAO,CAAC7B,uBAApD;AACH,OAFD,MAEO,IAAI,KAAKvD,IAAL,CAAU8D,QAAV,IAAsB,WAAWvD,IAAX,CAAgB6E,OAAO,CAAC5E,WAAxB,CAA1B,EAAgE;AACnEoE,QAAAA,IAAI,CAACxC,SAAL,CAAe,2BAAf,EAA4C,KAAKpC,IAAL,CAAU8D,QAAtD;AACH;;AAED,UAAI,CAAC,WAAWvD,IAAX,CAAgB6E,OAAO,CAAC5E,WAAxB,CAAD,IAAyC4E,OAAO,CAAC9B,kBAArD,EAAyE;AACrEsB,QAAAA,IAAI,CAACxC,SAAL,CAAe,qBAAf,EAAsCgD,OAAO,CAAC9B,kBAAR,KAA+B8B,OAAO,CAACxB,GAAR,GAAc,QAAd,GAAyB,YAAxD,CAAtC;AACH;;AAED,UAAI,OAAOwB,OAAO,CAAC1D,OAAf,KAA2B,QAA3B,IAAuC,CAAC,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,EAA6B4D,QAA7B,CAAsCxB,QAAtC,CAA5C,EAA6F;AACzFsB,QAAAA,OAAO,CAAC1D,OAAR,GAAkB6D,MAAM,CAACC,IAAP,CAAYJ,OAAO,CAAC1D,OAApB,EAA6BoC,QAA7B,CAAlB;AACH,OAlDmC,CAoDpC;;;AACA,UAAIsB,OAAO,CAAClE,GAAZ,EAAiB;AACb0D,QAAAA,IAAI,CAACzD,MAAL,CAAYiE,OAAO,CAAClE,GAApB;AACH,OAFD,MAEO;AACH0D,QAAAA,IAAI,CAACa,UAAL,CAAgBL,OAAO,CAAC1D,OAAxB;AACH;;AAED,aAAOkD,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;oCACoBQ,O,EAAS;AACrB,UAAIM,KAAK,GAAG,CAACN,OAAO,CAACnC,IAAR,IAAgBmC,OAAO,CAAClC,IAAzB,EAA+ByC,KAA/B,CAAqC,qCAArC,CAAZ;;AACA,UAAI,CAACD,KAAL,EAAY;AACR,eAAON,OAAP;AACH;;AAEDA,MAAAA,OAAO,CAAC1D,OAAR,GAAkB,aAAanB,IAAb,CAAkBmF,KAAK,CAAC,CAAD,CAAvB,IAA8BH,MAAM,CAACC,IAAP,CAAYE,KAAK,CAAC,CAAD,CAAjB,EAAsB,QAAtB,CAA9B,GAAgEH,MAAM,CAACC,IAAP,CAAYI,kBAAkB,CAACF,KAAK,CAAC,CAAD,CAAN,CAA9B,CAAlF;;AAEA,UAAI,UAAUN,OAAd,EAAuB;AACnBA,QAAAA,OAAO,CAACnC,IAAR,GAAe,KAAf;AACH;;AAED,UAAI,UAAUmC,OAAd,EAAuB;AACnBA,QAAAA,OAAO,CAAClC,IAAR,GAAe,KAAf;AACH;;AAEDwC,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASlC,KAAT,CAAe,GAAf,EAAoB3B,OAApB,CAA4B,UAAAgE,IAAI,EAAI;AAChC,YAAI,gBAAgBtF,IAAhB,CAAqBsF,IAArB,CAAJ,EAAgC;AAC5BT,UAAAA,OAAO,CAAC5E,WAAR,GAAsB4E,OAAO,CAAC5E,WAAR,IAAuBqF,IAAI,CAACR,WAAL,EAA7C;AACH;AACJ,OAJD;AAMA,aAAOD,OAAP;AACH;;;;;;AAGLU,MAAM,CAACC,OAAP,GAAiBhG,YAAjB","sourcesContent":["/* eslint no-undefined: 0 */\n\n'use strict';\n\nconst MimeNode = require('../mime-node');\nconst mimeFuncs = require('../mime-funcs');\n\n/**\n * Creates the object for composing a MimeNode instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\nclass MailComposer {\n    constructor(mail) {\n        this.mail = mail || {};\n        this.message = false;\n    }\n\n    /**\n     * Builds MimeNode instance\n     */\n    compile() {\n        this._alternatives = this.getAlternatives();\n        this._htmlNode = this._alternatives.filter(alternative => /^text\\/html\\b/i.test(alternative.contentType)).pop();\n        this._attachments = this.getAttachments(!!this._htmlNode);\n\n        this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n        this._useAlternative = this._alternatives.length > 1;\n        this._useMixed = this._attachments.attached.length > 1 || (this._alternatives.length && this._attachments.attached.length === 1);\n\n        // Compose MIME tree\n        if (this.mail.raw) {\n            this.message = new MimeNode().setRaw(this.mail.raw);\n        } else if (this._useMixed) {\n            this.message = this._createMixed();\n        } else if (this._useAlternative) {\n            this.message = this._createAlternative();\n        } else if (this._useRelated) {\n            this.message = this._createRelated();\n        } else {\n            this.message = this._createContentNode(\n                false,\n                []\n                    .concat(this._alternatives || [])\n                    .concat(this._attachments.attached || [])\n                    .shift() || {\n                    contentType: 'text/plain',\n                    content: ''\n                }\n            );\n        }\n\n        // Add custom headers\n        if (this.mail.headers) {\n            this.message.addHeader(this.mail.headers);\n        }\n\n        // Add headers to the root node, always overrides custom headers\n        ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(header => {\n            let key = header.replace(/-(\\w)/g, (o, c) => c.toUpperCase());\n            if (this.mail[key]) {\n                this.message.setHeader(header, this.mail[key]);\n            }\n        });\n\n        // Sets custom envelope\n        if (this.mail.envelope) {\n            this.message.setEnvelope(this.mail.envelope);\n        }\n\n        // ensure Message-Id value\n        this.message.messageId();\n\n        return this.message;\n    }\n\n    /**\n     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes\n     *\n     * @param {Boolean} findRelated If true separate related attachments from attached ones\n     * @returns {Object} An object of arrays (`related` and `attached`)\n     */\n    getAttachments(findRelated) {\n        let icalEvent, eventObject;\n        let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {\n            let data;\n            let isMessageNode = /^message\\//i.test(attachment.contentType);\n\n            if (/^data:/i.test(attachment.path || attachment.href)) {\n                attachment = this._processDataUrl(attachment);\n            }\n\n            data = {\n                contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),\n                contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),\n                contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'\n            };\n\n            if (attachment.filename) {\n                data.filename = attachment.filename;\n            } else if (!isMessageNode && attachment.filename !== false) {\n                data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n                if (data.filename.indexOf('.') < 0) {\n                    data.filename += '.' + mimeFuncs.detectExtension(data.contentType);\n                }\n            }\n\n            if (/^https?:\\/\\//i.test(attachment.path)) {\n                attachment.href = attachment.path;\n                attachment.path = undefined;\n            }\n\n            if (attachment.cid) {\n                data.cid = attachment.cid;\n            }\n\n            if (attachment.raw) {\n                data.raw = attachment.raw;\n            } else if (attachment.path) {\n                data.content = {\n                    path: attachment.path\n                };\n            } else if (attachment.href) {\n                data.content = {\n                    href: attachment.href,\n                    httpHeaders: attachment.httpHeaders\n                };\n            } else {\n                data.content = attachment.content || '';\n            }\n\n            if (attachment.encoding) {\n                data.encoding = attachment.encoding;\n            }\n\n            if (attachment.headers) {\n                data.headers = attachment.headers;\n            }\n\n            return data;\n        });\n\n        if (this.mail.icalEvent) {\n            if (\n                typeof this.mail.icalEvent === 'object' &&\n                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)\n            ) {\n                icalEvent = this.mail.icalEvent;\n            } else {\n                icalEvent = {\n                    content: this.mail.icalEvent\n                };\n            }\n\n            eventObject = {};\n            Object.keys(icalEvent).forEach(key => {\n                eventObject[key] = icalEvent[key];\n            });\n\n            eventObject.contentType = 'application/ics';\n            if (!eventObject.headers) {\n                eventObject.headers = {};\n            }\n            eventObject.filename = eventObject.filename || 'invite.ics';\n            eventObject.headers['Content-Disposition'] = 'attachment';\n            eventObject.headers['Content-Transfer-Encoding'] = 'base64';\n        }\n\n        if (!findRelated) {\n            return {\n                attached: attachments.concat(eventObject || []),\n                related: []\n            };\n        } else {\n            return {\n                attached: attachments.filter(attachment => !attachment.cid).concat(eventObject || []),\n                related: attachments.filter(attachment => !!attachment.cid)\n            };\n        }\n    }\n\n    /**\n     * List alternatives. Resulting objects can be used as input for MimeNode nodes\n     *\n     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n     */\n    getAlternatives() {\n        let alternatives = [],\n            text,\n            html,\n            watchHtml,\n            amp,\n            icalEvent,\n            eventObject;\n\n        if (this.mail.text) {\n            if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n                text = this.mail.text;\n            } else {\n                text = {\n                    content: this.mail.text\n                };\n            }\n            text.contentType = 'text/plain; charset=utf-8';\n        }\n\n        if (this.mail.watchHtml) {\n            if (\n                typeof this.mail.watchHtml === 'object' &&\n                (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)\n            ) {\n                watchHtml = this.mail.watchHtml;\n            } else {\n                watchHtml = {\n                    content: this.mail.watchHtml\n                };\n            }\n            watchHtml.contentType = 'text/watch-html; charset=utf-8';\n        }\n\n        if (this.mail.amp) {\n            if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {\n                amp = this.mail.amp;\n            } else {\n                amp = {\n                    content: this.mail.amp\n                };\n            }\n            amp.contentType = 'text/x-amp-html; charset=utf-8';\n        }\n\n        // only include the calendar alternative if there are no attachments\n        // otherwise you might end up in a blank screen on some clients\n        if (this.mail.icalEvent && !(this.mail.attachments && this.mail.attachments.length)) {\n            if (\n                typeof this.mail.icalEvent === 'object' &&\n                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)\n            ) {\n                icalEvent = this.mail.icalEvent;\n            } else {\n                icalEvent = {\n                    content: this.mail.icalEvent\n                };\n            }\n\n            eventObject = {};\n            Object.keys(icalEvent).forEach(key => {\n                eventObject[key] = icalEvent[key];\n            });\n\n            if (eventObject.content && typeof eventObject.content === 'object') {\n                // we are going to have the same attachment twice, so mark this to be\n                // resolved just once\n                eventObject.content._resolve = true;\n            }\n\n            eventObject.filename = false;\n            eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();\n            if (!eventObject.headers) {\n                eventObject.headers = {};\n            }\n        }\n\n        if (this.mail.html) {\n            if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n                html = this.mail.html;\n            } else {\n                html = {\n                    content: this.mail.html\n                };\n            }\n            html.contentType = 'text/html; charset=utf-8';\n        }\n\n        []\n            .concat(text || [])\n            .concat(watchHtml || [])\n            .concat(amp || [])\n            .concat(html || [])\n            .concat(eventObject || [])\n            .concat(this.mail.alternatives || [])\n            .forEach(alternative => {\n                let data;\n\n                if (/^data:/i.test(alternative.path || alternative.href)) {\n                    alternative = this._processDataUrl(alternative);\n                }\n\n                data = {\n                    contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n                    contentTransferEncoding: alternative.contentTransferEncoding\n                };\n\n                if (alternative.filename) {\n                    data.filename = alternative.filename;\n                }\n\n                if (/^https?:\\/\\//i.test(alternative.path)) {\n                    alternative.href = alternative.path;\n                    alternative.path = undefined;\n                }\n\n                if (alternative.raw) {\n                    data.raw = alternative.raw;\n                } else if (alternative.path) {\n                    data.content = {\n                        path: alternative.path\n                    };\n                } else if (alternative.href) {\n                    data.content = {\n                        href: alternative.href\n                    };\n                } else {\n                    data.content = alternative.content || '';\n                }\n\n                if (alternative.encoding) {\n                    data.encoding = alternative.encoding;\n                }\n\n                if (alternative.headers) {\n                    data.headers = alternative.headers;\n                }\n\n                alternatives.push(data);\n            });\n\n        return alternatives;\n    }\n\n    /**\n     * Builds multipart/mixed node. It should always contain different type of elements on the same level\n     * eg. text + attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createMixed(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/mixed', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        } else {\n            node = parentNode.createChild('multipart/mixed', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        }\n\n        if (this._useAlternative) {\n            this._createAlternative(node);\n        } else if (this._useRelated) {\n            this._createRelated(node);\n        }\n\n        []\n            .concat((!this._useAlternative && this._alternatives) || [])\n            .concat(this._attachments.attached || [])\n            .forEach(element => {\n                // if the element is a html node from related subpart then ignore it\n                if (!this._useRelated || element !== this._htmlNode) {\n                    this._createContentNode(node, element);\n                }\n            });\n\n        return node;\n    }\n\n    /**\n     * Builds multipart/alternative node. It should always contain same type of elements on the same level\n     * eg. text + html view of the same data\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createAlternative(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/alternative', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        } else {\n            node = parentNode.createChild('multipart/alternative', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        }\n\n        this._alternatives.forEach(alternative => {\n            if (this._useRelated && this._htmlNode === alternative) {\n                this._createRelated(node);\n            } else {\n                this._createContentNode(node, alternative);\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Builds multipart/related node. It should always contain html node with related attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createRelated(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/related; type=\"text/html\"', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        } else {\n            node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        }\n\n        this._createContentNode(node, this._htmlNode);\n\n        this._attachments.related.forEach(alternative => this._createContentNode(node, alternative));\n\n        return node;\n    }\n\n    /**\n     * Creates a regular node with contents\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @param {Object} element Node data\n     * @returns {Object} MimeNode node element\n     */\n    _createContentNode(parentNode, element) {\n        element = element || {};\n        element.content = element.content || '';\n\n        let node;\n        let encoding = (element.encoding || 'utf8')\n            .toString()\n            .toLowerCase()\n            .replace(/[-_\\s]/g, '');\n\n        if (!parentNode) {\n            node = new MimeNode(element.contentType, {\n                filename: element.filename,\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        } else {\n            node = parentNode.createChild(element.contentType, {\n                filename: element.filename,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey\n            });\n        }\n\n        // add custom headers\n        if (element.headers) {\n            node.addHeader(element.headers);\n        }\n\n        if (element.cid) {\n            node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n        }\n\n        if (element.contentTransferEncoding) {\n            node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n        } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n            node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n        }\n\n        if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n            node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));\n        }\n\n        if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n            element.content = Buffer.from(element.content, encoding);\n        }\n\n        // prefer pregenerated raw content\n        if (element.raw) {\n            node.setRaw(element.raw);\n        } else {\n            node.setContent(element.content);\n        }\n\n        return node;\n    }\n\n    /**\n     * Parses data uri and converts it to a Buffer\n     *\n     * @param {Object} element Content element\n     * @return {Object} Parsed element\n     */\n    _processDataUrl(element) {\n        let parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n        if (!parts) {\n            return element;\n        }\n\n        element.content = /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2]));\n\n        if ('path' in element) {\n            element.path = false;\n        }\n\n        if ('href' in element) {\n            element.href = false;\n        }\n\n        parts[1].split(';').forEach(item => {\n            if (/^\\w+\\/[^/]+$/i.test(item)) {\n                element.contentType = element.contentType || item.toLowerCase();\n            }\n        });\n\n        return element;\n    }\n}\n\nmodule.exports = MailComposer;\n"]},"metadata":{},"sourceType":"script"}