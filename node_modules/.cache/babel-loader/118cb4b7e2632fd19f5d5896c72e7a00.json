{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar net = require(\"net\");\n\nvar ip = require(\"ip\");\n\nvar smart_buffer_1 = require(\"smart-buffer\");\n\nvar constants_1 = require(\"../common/constants\");\n\nvar helpers_1 = require(\"../common/helpers\");\n\nvar receivebuffer_1 = require(\"../common/receivebuffer\");\n\nvar util_1 = require(\"../common/util\");\n\nvar SocksClient = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(SocksClient, _events_1$EventEmitte);\n\n  var _super = _createSuper(SocksClient);\n\n  function SocksClient(options) {\n    var _this;\n\n    _classCallCheck(this, SocksClient);\n\n    _this = _super.call(this);\n    _this._options = Object.assign({}, options); // Validate SocksClientOptions\n\n    helpers_1.validateSocksClientOptions(options); // Default state\n\n    _this.state = constants_1.SocksClientState.Created;\n    return _this;\n  }\n  /**\n   * Creates a new SOCKS connection.\n   *\n   * Note: Supports callbacks and promises. Only supports the connect command.\n   * @param options { SocksClientOptions } Options.\n   * @param callback { Function } An optional callback function.\n   * @returns { Promise }\n   */\n\n\n  _createClass(SocksClient, [{\n    key: \"connect\",\n\n    /**\n     * Starts the connection establishment to the proxy and destination.\n     * @param existing_socket Connected socket to use instead of creating a new one (internal use).\n     */\n    value: function connect(existing_socket) {\n      var _this2 = this;\n\n      this._onDataReceived = function (data) {\n        return _this2.onDataReceived(data);\n      };\n\n      this._onClose = function () {\n        return _this2.onClose();\n      };\n\n      this._onError = function (err) {\n        return _this2.onError(err);\n      };\n\n      this._onConnect = function () {\n        return _this2.onConnect();\n      }; // Start timeout timer (defaults to 30 seconds)\n\n\n      var timer = setTimeout(function () {\n        return _this2.onEstablishedTimeout();\n      }, this._options.timeout || constants_1.DEFAULT_TIMEOUT); // check whether unref is available as it differs from browser to NodeJS (#33)\n\n      if (timer.unref && typeof timer.unref === 'function') {\n        timer.unref();\n      } // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.\n\n\n      if (existing_socket) {\n        this._socket = existing_socket;\n      } else {\n        this._socket = new net.Socket();\n      } // Attach Socket error handlers.\n\n\n      this._socket.once('close', this._onClose);\n\n      this._socket.once('error', this._onError);\n\n      this._socket.once('connect', this._onConnect);\n\n      this._socket.on('data', this._onDataReceived);\n\n      this.state = constants_1.SocksClientState.Connecting;\n      this._receiveBuffer = new receivebuffer_1.ReceiveBuffer();\n\n      if (existing_socket) {\n        this._socket.emit('connect');\n      } else {\n        this._socket.connect(this.getSocketOptions());\n\n        if (this._options.set_tcp_nodelay !== undefined && this._options.set_tcp_nodelay !== null) {\n          this._socket.setNoDelay(!!this._options.set_tcp_nodelay);\n        }\n      } // Listen for established event so we can re-emit any excess data received during handshakes.\n\n\n      this.prependOnceListener('established', function (info) {\n        setImmediate(function () {\n          if (_this2._receiveBuffer.length > 0) {\n            var excessData = _this2._receiveBuffer.get(_this2._receiveBuffer.length);\n\n            info.socket.emit('data', excessData);\n          }\n\n          info.socket.resume();\n        });\n      });\n    } // Socket options (defaults host/port to options.proxy.host/options.proxy.port)\n\n  }, {\n    key: \"getSocketOptions\",\n    value: function getSocketOptions() {\n      return Object.assign(Object.assign({}, this._options.socket_options), {\n        host: this._options.proxy.host || this._options.proxy.ipaddress,\n        port: this._options.proxy.port\n      });\n    }\n    /**\n     * Handles internal Socks timeout callback.\n     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.\n     */\n\n  }, {\n    key: \"onEstablishedTimeout\",\n    value: function onEstablishedTimeout() {\n      if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {\n        this._closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);\n      }\n    }\n    /**\n     * Handles Socket connect event.\n     */\n\n  }, {\n    key: \"onConnect\",\n    value: function onConnect() {\n      this.state = constants_1.SocksClientState.Connected; // Send initial handshake.\n\n      if (this._options.proxy.type === 4) {\n        this.sendSocks4InitialHandshake();\n      } else {\n        this.sendSocks5InitialHandshake();\n      }\n\n      this.state = constants_1.SocksClientState.SentInitialHandshake;\n    }\n    /**\n     * Handles Socket data event.\n     * @param data\n     */\n\n  }, {\n    key: \"onDataReceived\",\n    value: function onDataReceived(data) {\n      /*\n        All received data is appended to a ReceiveBuffer.\n        This makes sure that all the data we need is received before we attempt to process it.\n      */\n      this._receiveBuffer.append(data); // Process data that we have.\n\n\n      this.processData();\n    }\n    /**\n     * Handles processing of the data we have received.\n     */\n\n  }, {\n    key: \"processData\",\n    value: function processData() {\n      // If we have enough data to process the next step in the SOCKS handshake, proceed.\n      if (this._receiveBuffer.length >= this._nextRequiredPacketBufferSize) {\n        // Sent initial handshake, waiting for response.\n        if (this.state === constants_1.SocksClientState.SentInitialHandshake) {\n          if (this._options.proxy.type === 4) {\n            // Socks v4 only has one handshake response.\n            this.handleSocks4FinalHandshakeResponse();\n          } else {\n            // Socks v5 has two handshakes, handle initial one here.\n            this.handleInitialSocks5HandshakeResponse();\n          } // Sent auth request for Socks v5, waiting for response.\n\n        } else if (this.state === constants_1.SocksClientState.SentAuthentication) {\n          this.handleInitialSocks5AuthenticationHandshakeResponse(); // Sent final Socks v5 handshake, waiting for final response.\n        } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {\n          this.handleSocks5FinalHandshakeResponse(); // Socks BIND established. Waiting for remote connection via proxy.\n        } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {\n          if (this._options.proxy.type === 4) {\n            this.handleSocks4IncomingConnectionResponse();\n          } else {\n            this.handleSocks5IncomingConnectionResponse();\n          }\n        } else if (this.state === constants_1.SocksClientState.Established) {// do nothing (prevents closing of the socket)\n        } else {\n          this._closeSocket(constants_1.ERRORS.InternalError);\n        }\n      }\n    }\n    /**\n     * Handles Socket close event.\n     * @param had_error\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      this._closeSocket(constants_1.ERRORS.SocketClosed);\n    }\n    /**\n     * Handles Socket error event.\n     * @param err\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(err) {\n      this._closeSocket(err.message);\n    }\n    /**\n     * Removes internal event listeners on the underlying Socket.\n     */\n\n  }, {\n    key: \"removeInternalSocketHandlers\",\n    value: function removeInternalSocketHandlers() {\n      // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)\n      this._socket.pause();\n\n      this._socket.removeListener('data', this._onDataReceived);\n\n      this._socket.removeListener('close', this._onClose);\n\n      this._socket.removeListener('error', this._onError);\n\n      this._socket.removeListener('connect', this.onConnect);\n    }\n    /**\n     * Closes and destroys the underlying Socket. Emits an error event.\n     * @param err { String } An error string to include in error event.\n     */\n\n  }, {\n    key: \"_closeSocket\",\n    value: function _closeSocket(err) {\n      // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.\n      if (this.state !== constants_1.SocksClientState.Error) {\n        // Set internal state to Error.\n        this.state = constants_1.SocksClientState.Error; // Destroy Socket\n\n        this._socket.destroy(); // Remove internal listeners\n\n\n        this.removeInternalSocketHandlers(); // Fire 'error' event.\n\n        this.emit('error', new util_1.SocksClientError(err, this._options));\n      }\n    }\n    /**\n     * Sends initial Socks v4 handshake request.\n     */\n\n  }, {\n    key: \"sendSocks4InitialHandshake\",\n    value: function sendSocks4InitialHandshake() {\n      var userId = this._options.proxy.userId || '';\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x04);\n      buff.writeUInt8(constants_1.SocksCommand[this._options.command]);\n      buff.writeUInt16BE(this._options.destination.port); // Socks 4 (IPv4)\n\n      if (net.isIPv4(this._options.destination.host)) {\n        buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n        buff.writeStringNT(userId); // Socks 4a (hostname)\n      } else {\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x01);\n        buff.writeStringNT(userId);\n        buff.writeStringNT(this._options.destination.host);\n      }\n\n      this._nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;\n\n      this._socket.write(buff.toBuffer());\n    }\n    /**\n     * Handles Socks v4 handshake response.\n     * @param data\n     */\n\n  }, {\n    key: \"handleSocks4FinalHandshakeResponse\",\n    value: function handleSocks4FinalHandshakeResponse() {\n      var data = this._receiveBuffer.get(8);\n\n      if (data[1] !== constants_1.Socks4Response.Granted) {\n        this._closeSocket(\"\".concat(constants_1.ERRORS.Socks4ProxyRejectedConnection, \" - (\").concat(constants_1.Socks4Response[data[1]], \")\"));\n      } else {\n        // Bind response\n        if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.bind) {\n          var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n          buff.readOffset = 2;\n          var remoteHost = {\n            port: buff.readUInt16BE(),\n            host: ip.fromLong(buff.readUInt32BE())\n          }; // If host is 0.0.0.0, set to proxy host.\n\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this._options.proxy.ipaddress;\n          }\n\n          this.state = constants_1.SocksClientState.BoundWaitingForConnection;\n          this.emit('bound', {\n            socket: this._socket,\n            remoteHost: remoteHost\n          }); // Connect response\n        } else {\n          this.state = constants_1.SocksClientState.Established;\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            socket: this._socket\n          });\n        }\n      }\n    }\n    /**\n     * Handles Socks v4 incoming connection request (BIND)\n     * @param data\n     */\n\n  }, {\n    key: \"handleSocks4IncomingConnectionResponse\",\n    value: function handleSocks4IncomingConnectionResponse() {\n      var data = this._receiveBuffer.get(8);\n\n      if (data[1] !== constants_1.Socks4Response.Granted) {\n        this._closeSocket(\"\".concat(constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection, \" - (\").concat(constants_1.Socks4Response[data[1]], \")\"));\n      } else {\n        var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n        buff.readOffset = 2;\n        var remoteHost = {\n          port: buff.readUInt16BE(),\n          host: ip.fromLong(buff.readUInt32BE())\n        };\n        this.state = constants_1.SocksClientState.Established;\n        this.removeInternalSocketHandlers();\n        this.emit('established', {\n          socket: this._socket,\n          remoteHost: remoteHost\n        });\n      }\n    }\n    /**\n     * Sends initial Socks v5 handshake request.\n     */\n\n  }, {\n    key: \"sendSocks5InitialHandshake\",\n    value: function sendSocks5InitialHandshake() {\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x05); // We should only tell the proxy we support user/pass auth if auth info is actually provided.\n      // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.\n\n      if (this._options.proxy.userId || this._options.proxy.password) {\n        buff.writeUInt8(2);\n        buff.writeUInt8(constants_1.Socks5Auth.NoAuth);\n        buff.writeUInt8(constants_1.Socks5Auth.UserPass);\n      } else {\n        buff.writeUInt8(1);\n        buff.writeUInt8(constants_1.Socks5Auth.NoAuth);\n      }\n\n      this._nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;\n\n      this._socket.write(buff.toBuffer());\n\n      this.state = constants_1.SocksClientState.SentInitialHandshake;\n    }\n    /**\n     * Handles initial Socks v5 handshake response.\n     * @param data\n     */\n\n  }, {\n    key: \"handleInitialSocks5HandshakeResponse\",\n    value: function handleInitialSocks5HandshakeResponse() {\n      var data = this._receiveBuffer.get(2);\n\n      if (data[0] !== 0x05) {\n        this._closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);\n      } else if (data[1] === 0xff) {\n        this._closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);\n      } else {\n        // If selected Socks v5 auth method is no auth, send final handshake request.\n        if (data[1] === constants_1.Socks5Auth.NoAuth) {\n          this.sendSocks5CommandRequest(); // If selected Socks v5 auth method is user/password, send auth handshake.\n        } else if (data[1] === constants_1.Socks5Auth.UserPass) {\n          this.sendSocks5UserPassAuthentication();\n        } else {\n          this._closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);\n        }\n      }\n    }\n    /**\n     * Sends Socks v5 user & password auth handshake.\n     *\n     * Note: No auth and user/pass are currently supported.\n     */\n\n  }, {\n    key: \"sendSocks5UserPassAuthentication\",\n    value: function sendSocks5UserPassAuthentication() {\n      var userId = this._options.proxy.userId || '';\n      var password = this._options.proxy.password || '';\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x01);\n      buff.writeUInt8(Buffer.byteLength(userId));\n      buff.writeString(userId);\n      buff.writeUInt8(Buffer.byteLength(password));\n      buff.writeString(password);\n      this._nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;\n\n      this._socket.write(buff.toBuffer());\n\n      this.state = constants_1.SocksClientState.SentAuthentication;\n    }\n    /**\n     * Handles Socks v5 auth handshake response.\n     * @param data\n     */\n\n  }, {\n    key: \"handleInitialSocks5AuthenticationHandshakeResponse\",\n    value: function handleInitialSocks5AuthenticationHandshakeResponse() {\n      this.state = constants_1.SocksClientState.ReceivedAuthenticationResponse;\n\n      var data = this._receiveBuffer.get(2);\n\n      if (data[1] !== 0x00) {\n        this._closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);\n      } else {\n        this.sendSocks5CommandRequest();\n      }\n    }\n    /**\n     * Sends Socks v5 final handshake request.\n     */\n\n  }, {\n    key: \"sendSocks5CommandRequest\",\n    value: function sendSocks5CommandRequest() {\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x05);\n      buff.writeUInt8(constants_1.SocksCommand[this._options.command]);\n      buff.writeUInt8(0x00); // ipv4, ipv6, domain?\n\n      if (net.isIPv4(this._options.destination.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n        buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n      } else if (net.isIPv6(this._options.destination.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n        buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n      } else {\n        buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n        buff.writeUInt8(this._options.destination.host.length);\n        buff.writeString(this._options.destination.host);\n      }\n\n      buff.writeUInt16BE(this._options.destination.port);\n      this._nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n\n      this._socket.write(buff.toBuffer());\n\n      this.state = constants_1.SocksClientState.SentFinalHandshake;\n    }\n    /**\n     * Handles Socks v5 final handshake response.\n     * @param data\n     */\n\n  }, {\n    key: \"handleSocks5FinalHandshakeResponse\",\n    value: function handleSocks5FinalHandshakeResponse() {\n      // Peek at available data (we need at least 5 bytes to get the hostname length)\n      var header = this._receiveBuffer.peek(5);\n\n      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n        this._closeSocket(\"\".concat(constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected, \" - \").concat(constants_1.Socks5Response[header[1]]));\n      } else {\n        // Read address type\n        var addressType = header[3];\n        var remoteHost;\n        var buff; // IPv4\n\n        if (addressType === constants_1.Socks5HostType.IPv4) {\n          // Check if data is available.\n          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n\n          if (this._receiveBuffer.length < dataNeeded) {\n            this._nextRequiredPacketBufferSize = dataNeeded;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n          remoteHost = {\n            host: ip.fromLong(buff.readUInt32BE()),\n            port: buff.readUInt16BE()\n          }; // If given host is 0.0.0.0, assume remote proxy ip instead.\n\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this._options.proxy.ipaddress;\n          } // Hostname\n\n        } else if (addressType === constants_1.Socks5HostType.Hostname) {\n          var hostLength = header[4];\n\n          var _dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port\n          // Check if data is available.\n\n\n          if (this._receiveBuffer.length < _dataNeeded) {\n            this._nextRequiredPacketBufferSize = _dataNeeded;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(_dataNeeded).slice(5) // Slice at 5 to skip host length\n          );\n          remoteHost = {\n            host: buff.readString(hostLength),\n            port: buff.readUInt16BE()\n          }; // IPv6\n        } else if (addressType === constants_1.Socks5HostType.IPv6) {\n          // Check if data is available.\n          var _dataNeeded2 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n\n          if (this._receiveBuffer.length < _dataNeeded2) {\n            this._nextRequiredPacketBufferSize = _dataNeeded2;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(_dataNeeded2).slice(4));\n          remoteHost = {\n            host: ip.toString(buff.readBuffer(16)),\n            port: buff.readUInt16BE()\n          };\n        } // We have everything we need\n\n\n        this.state = constants_1.SocksClientState.ReceivedFinalResponse; // If using CONNECT, the client is now in the established state.\n\n        if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.connect) {\n          this.state = constants_1.SocksClientState.Established;\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            socket: this._socket\n          });\n        } else if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.bind) {\n          /* If using BIND, the Socks client is now in BoundWaitingForConnection state.\n             This means that the remote proxy server is waiting for a remote connection to the bound port. */\n          this.state = constants_1.SocksClientState.BoundWaitingForConnection;\n          this._nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n          this.emit('bound', {\n            socket: this._socket,\n            remoteHost: remoteHost\n          });\n          /*\n            If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the\n            given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.\n          */\n        } else if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.associate) {\n          this.state = constants_1.SocksClientState.Established;\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            socket: this._socket,\n            remoteHost: remoteHost\n          });\n        }\n      }\n    }\n    /**\n     * Handles Socks v5 incoming connection request (BIND).\n     */\n\n  }, {\n    key: \"handleSocks5IncomingConnectionResponse\",\n    value: function handleSocks5IncomingConnectionResponse() {\n      // Peek at available data (we need at least 5 bytes to get the hostname length)\n      var header = this._receiveBuffer.peek(5);\n\n      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n        this._closeSocket(\"\".concat(constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection, \" - \").concat(constants_1.Socks5Response[header[1]]));\n      } else {\n        // Read address type\n        var addressType = header[3];\n        var remoteHost;\n        var buff; // IPv4\n\n        if (addressType === constants_1.Socks5HostType.IPv4) {\n          // Check if data is available.\n          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n\n          if (this._receiveBuffer.length < dataNeeded) {\n            this._nextRequiredPacketBufferSize = dataNeeded;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n          remoteHost = {\n            host: ip.fromLong(buff.readUInt32BE()),\n            port: buff.readUInt16BE()\n          }; // If given host is 0.0.0.0, assume remote proxy ip instead.\n\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this._options.proxy.ipaddress;\n          } // Hostname\n\n        } else if (addressType === constants_1.Socks5HostType.Hostname) {\n          var hostLength = header[4];\n\n          var _dataNeeded3 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port\n          // Check if data is available.\n\n\n          if (this._receiveBuffer.length < _dataNeeded3) {\n            this._nextRequiredPacketBufferSize = _dataNeeded3;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(_dataNeeded3).slice(5) // Slice at 5 to skip host length\n          );\n          remoteHost = {\n            host: buff.readString(hostLength),\n            port: buff.readUInt16BE()\n          }; // IPv6\n        } else if (addressType === constants_1.Socks5HostType.IPv6) {\n          // Check if data is available.\n          var _dataNeeded4 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n\n          if (this._receiveBuffer.length < _dataNeeded4) {\n            this._nextRequiredPacketBufferSize = _dataNeeded4;\n            return;\n          }\n\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(_dataNeeded4).slice(4));\n          remoteHost = {\n            host: ip.toString(buff.readBuffer(16)),\n            port: buff.readUInt16BE()\n          };\n        }\n\n        this.state = constants_1.SocksClientState.Established;\n        this.removeInternalSocketHandlers();\n        this.emit('established', {\n          socket: this._socket,\n          remoteHost: remoteHost\n        });\n      }\n    }\n  }, {\n    key: \"state\",\n\n    /**\n     * Gets the SocksClient internal state.\n     */\n    get: function get() {\n      return this._state;\n    }\n    /**\n     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.\n     */\n    ,\n    set: function set(newState) {\n      if (this._state !== constants_1.SocksClientState.Error) {\n        this._state = newState;\n      }\n    }\n  }, {\n    key: \"socksClientOptions\",\n    get: function get() {\n      return Object.assign({}, this._options);\n    }\n  }], [{\n    key: \"createConnection\",\n    value: function createConnection(options, callback) {\n      // Validate SocksClientOptions\n      helpers_1.validateSocksClientOptions(options, ['connect']);\n      return new Promise(function (resolve, reject) {\n        var client = new SocksClient(options);\n        client.connect(options.existing_socket);\n        client.once('established', function (info) {\n          client.removeAllListeners();\n\n          if (typeof callback === 'function') {\n            callback(null, info);\n            resolve(); // Resolves pending promise (prevents memory leaks).\n          } else {\n            resolve(info);\n          }\n        }); // Error occurred, failed to establish connection.\n\n        client.once('error', function (err) {\n          client.removeAllListeners();\n\n          if (typeof callback === 'function') {\n            callback(err);\n            resolve(); // Resolves pending promise (prevents memory leaks).\n          } else {\n            reject(err);\n          }\n        });\n      });\n    }\n    /**\n     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect method.\n     * Note: Implemented via createConnection() factory function.\n     * @param options { SocksClientChainOptions } Options\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n\n  }, {\n    key: \"createConnectionChain\",\n    value: function createConnectionChain(options, callback) {\n      var _this3 = this;\n\n      // Validate SocksClientChainOptions\n      helpers_1.validateSocksClientChainOptions(options); // Shuffle proxies\n\n      if (options.randomizeChain) {\n        util_1.shuffleArray(options.proxies);\n      }\n\n      return new Promise(function (resolve, reject) {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var sock, i, nextProxy, nextDestination, result;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  i = 0;\n\n                case 2:\n                  if (!(i < options.proxies.length)) {\n                    _context.next = 12;\n                    break;\n                  }\n\n                  nextProxy = options.proxies[i]; // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.\n\n                  nextDestination = i === options.proxies.length - 1 ? options.destination : {\n                    host: options.proxies[i + 1].ipaddress,\n                    port: options.proxies[i + 1].port\n                  }; // Creates the next connection in the chain.\n\n                  _context.next = 7;\n                  return SocksClient.createConnection({\n                    command: 'connect',\n                    proxy: nextProxy,\n                    destination: nextDestination // Initial connection ignores this as sock is undefined. Subsequent connections re-use the first proxy socket to form a chain.\n\n                  });\n\n                case 7:\n                  result = _context.sent;\n\n                  // If sock is undefined, assign it here.\n                  if (!sock) {\n                    sock = result.socket;\n                  }\n\n                case 9:\n                  i++;\n                  _context.next = 2;\n                  break;\n\n                case 12:\n                  if (typeof callback === 'function') {\n                    callback(null, {\n                      socket: sock\n                    });\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                  } else {\n                    resolve({\n                      socket: sock\n                    });\n                  }\n\n                  _context.next = 18;\n                  break;\n\n                case 15:\n                  _context.prev = 15;\n                  _context.t0 = _context[\"catch\"](0);\n\n                  if (typeof callback === 'function') {\n                    callback(_context.t0);\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                  } else {\n                    reject(_context.t0);\n                  }\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 15]]);\n        }));\n      });\n    }\n    /**\n     * Creates a SOCKS UDP Frame.\n     * @param options\n     */\n\n  }, {\n    key: \"createUDPFrame\",\n    value: function createUDPFrame(options) {\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt16BE(0);\n      buff.writeUInt8(options.frameNumber || 0); // IPv4/IPv6/Hostname\n\n      if (net.isIPv4(options.remoteHost.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n        buff.writeUInt32BE(ip.toLong(options.remoteHost.host));\n      } else if (net.isIPv6(options.remoteHost.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n        buff.writeBuffer(ip.toBuffer(options.remoteHost.host));\n      } else {\n        buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));\n        buff.writeString(options.remoteHost.host);\n      } // Port\n\n\n      buff.writeUInt16BE(options.remoteHost.port); // Data\n\n      buff.writeBuffer(options.data);\n      return buff.toBuffer();\n    }\n    /**\n     * Parses a SOCKS UDP frame.\n     * @param data\n     */\n\n  }, {\n    key: \"parseUDPFrame\",\n    value: function parseUDPFrame(data) {\n      var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n      buff.readOffset = 2;\n      var frameNumber = buff.readUInt8();\n      var hostType = buff.readUInt8();\n      var remoteHost;\n\n      if (hostType === constants_1.Socks5HostType.IPv4) {\n        remoteHost = ip.fromLong(buff.readUInt32BE());\n      } else if (hostType === constants_1.Socks5HostType.IPv6) {\n        remoteHost = ip.toString(buff.readBuffer(16));\n      } else {\n        remoteHost = buff.readString(buff.readUInt8());\n      }\n\n      var remotePort = buff.readUInt16BE();\n      return {\n        frameNumber: frameNumber,\n        remoteHost: {\n          host: remoteHost,\n          port: remotePort\n        },\n        data: buff.readBuffer()\n      };\n    }\n  }]);\n\n  return SocksClient;\n}(events_1.EventEmitter);\n\nexports.SocksClient = SocksClient;","map":{"version":3,"sources":["../../src/client/socksclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst net = require(\"net\");\nconst ip = require(\"ip\");\nconst smart_buffer_1 = require(\"smart-buffer\");\nconst constants_1 = require(\"../common/constants\");\nconst helpers_1 = require(\"../common/helpers\");\nconst receivebuffer_1 = require(\"../common/receivebuffer\");\nconst util_1 = require(\"../common/util\");\nclass SocksClient extends events_1.EventEmitter {\n    constructor(options) {\n        super();\n        this._options = Object.assign({}, options);\n        // Validate SocksClientOptions\n        helpers_1.validateSocksClientOptions(options);\n        // Default state\n        this.state = constants_1.SocksClientState.Created;\n    }\n    /**\n     * Creates a new SOCKS connection.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect command.\n     * @param options { SocksClientOptions } Options.\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n    static createConnection(options, callback) {\n        // Validate SocksClientOptions\n        helpers_1.validateSocksClientOptions(options, ['connect']);\n        return new Promise((resolve, reject) => {\n            const client = new SocksClient(options);\n            client.connect(options.existing_socket);\n            client.once('established', (info) => {\n                client.removeAllListeners();\n                if (typeof callback === 'function') {\n                    callback(null, info);\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    resolve(info);\n                }\n            });\n            // Error occurred, failed to establish connection.\n            client.once('error', (err) => {\n                client.removeAllListeners();\n                if (typeof callback === 'function') {\n                    callback(err);\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect method.\n     * Note: Implemented via createConnection() factory function.\n     * @param options { SocksClientChainOptions } Options\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n    static createConnectionChain(options, callback) {\n        // Validate SocksClientChainOptions\n        helpers_1.validateSocksClientChainOptions(options);\n        // Shuffle proxies\n        if (options.randomizeChain) {\n            util_1.shuffleArray(options.proxies);\n        }\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let sock;\n            try {\n                for (let i = 0; i < options.proxies.length; i++) {\n                    const nextProxy = options.proxies[i];\n                    // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.\n                    const nextDestination = i === options.proxies.length - 1\n                        ? options.destination\n                        : {\n                            host: options.proxies[i + 1].ipaddress,\n                            port: options.proxies[i + 1].port\n                        };\n                    // Creates the next connection in the chain.\n                    const result = yield SocksClient.createConnection({\n                        command: 'connect',\n                        proxy: nextProxy,\n                        destination: nextDestination\n                        // Initial connection ignores this as sock is undefined. Subsequent connections re-use the first proxy socket to form a chain.\n                    });\n                    // If sock is undefined, assign it here.\n                    if (!sock) {\n                        sock = result.socket;\n                    }\n                }\n                if (typeof callback === 'function') {\n                    callback(null, { socket: sock });\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    resolve({ socket: sock });\n                }\n            }\n            catch (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                    resolve(); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    reject(err);\n                }\n            }\n        }));\n    }\n    /**\n     * Creates a SOCKS UDP Frame.\n     * @param options\n     */\n    static createUDPFrame(options) {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt16BE(0);\n        buff.writeUInt8(options.frameNumber || 0);\n        // IPv4/IPv6/Hostname\n        if (net.isIPv4(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeUInt32BE(ip.toLong(options.remoteHost.host));\n        }\n        else if (net.isIPv6(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer(ip.toBuffer(options.remoteHost.host));\n        }\n        else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));\n            buff.writeString(options.remoteHost.host);\n        }\n        // Port\n        buff.writeUInt16BE(options.remoteHost.port);\n        // Data\n        buff.writeBuffer(options.data);\n        return buff.toBuffer();\n    }\n    /**\n     * Parses a SOCKS UDP frame.\n     * @param data\n     */\n    static parseUDPFrame(data) {\n        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n        buff.readOffset = 2;\n        const frameNumber = buff.readUInt8();\n        const hostType = buff.readUInt8();\n        let remoteHost;\n        if (hostType === constants_1.Socks5HostType.IPv4) {\n            remoteHost = ip.fromLong(buff.readUInt32BE());\n        }\n        else if (hostType === constants_1.Socks5HostType.IPv6) {\n            remoteHost = ip.toString(buff.readBuffer(16));\n        }\n        else {\n            remoteHost = buff.readString(buff.readUInt8());\n        }\n        const remotePort = buff.readUInt16BE();\n        return {\n            frameNumber,\n            remoteHost: {\n                host: remoteHost,\n                port: remotePort\n            },\n            data: buff.readBuffer()\n        };\n    }\n    /**\n     * Gets the SocksClient internal state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.\n     */\n    set state(newState) {\n        if (this._state !== constants_1.SocksClientState.Error) {\n            this._state = newState;\n        }\n    }\n    /**\n     * Starts the connection establishment to the proxy and destination.\n     * @param existing_socket Connected socket to use instead of creating a new one (internal use).\n     */\n    connect(existing_socket) {\n        this._onDataReceived = (data) => this.onDataReceived(data);\n        this._onClose = () => this.onClose();\n        this._onError = (err) => this.onError(err);\n        this._onConnect = () => this.onConnect();\n        // Start timeout timer (defaults to 30 seconds)\n        const timer = setTimeout(() => this.onEstablishedTimeout(), this._options.timeout || constants_1.DEFAULT_TIMEOUT);\n        // check whether unref is available as it differs from browser to NodeJS (#33)\n        if (timer.unref && typeof timer.unref === 'function') {\n            timer.unref();\n        }\n        // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.\n        if (existing_socket) {\n            this._socket = existing_socket;\n        }\n        else {\n            this._socket = new net.Socket();\n        }\n        // Attach Socket error handlers.\n        this._socket.once('close', this._onClose);\n        this._socket.once('error', this._onError);\n        this._socket.once('connect', this._onConnect);\n        this._socket.on('data', this._onDataReceived);\n        this.state = constants_1.SocksClientState.Connecting;\n        this._receiveBuffer = new receivebuffer_1.ReceiveBuffer();\n        if (existing_socket) {\n            this._socket.emit('connect');\n        }\n        else {\n            this._socket.connect(this.getSocketOptions());\n            if (this._options.set_tcp_nodelay !== undefined &&\n                this._options.set_tcp_nodelay !== null) {\n                this._socket.setNoDelay(!!this._options.set_tcp_nodelay);\n            }\n        }\n        // Listen for established event so we can re-emit any excess data received during handshakes.\n        this.prependOnceListener('established', info => {\n            setImmediate(() => {\n                if (this._receiveBuffer.length > 0) {\n                    const excessData = this._receiveBuffer.get(this._receiveBuffer.length);\n                    info.socket.emit('data', excessData);\n                }\n                info.socket.resume();\n            });\n        });\n    }\n    // Socket options (defaults host/port to options.proxy.host/options.proxy.port)\n    getSocketOptions() {\n        return Object.assign(Object.assign({}, this._options.socket_options), { host: this._options.proxy.host || this._options.proxy.ipaddress, port: this._options.proxy.port });\n    }\n    /**\n     * Handles internal Socks timeout callback.\n     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.\n     */\n    onEstablishedTimeout() {\n        if (this.state !== constants_1.SocksClientState.Established &&\n            this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {\n            this._closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);\n        }\n    }\n    /**\n     * Handles Socket connect event.\n     */\n    onConnect() {\n        this.state = constants_1.SocksClientState.Connected;\n        // Send initial handshake.\n        if (this._options.proxy.type === 4) {\n            this.sendSocks4InitialHandshake();\n        }\n        else {\n            this.sendSocks5InitialHandshake();\n        }\n        this.state = constants_1.SocksClientState.SentInitialHandshake;\n    }\n    /**\n     * Handles Socket data event.\n     * @param data\n     */\n    onDataReceived(data) {\n        /*\n          All received data is appended to a ReceiveBuffer.\n          This makes sure that all the data we need is received before we attempt to process it.\n        */\n        this._receiveBuffer.append(data);\n        // Process data that we have.\n        this.processData();\n    }\n    /**\n     * Handles processing of the data we have received.\n     */\n    processData() {\n        // If we have enough data to process the next step in the SOCKS handshake, proceed.\n        if (this._receiveBuffer.length >= this._nextRequiredPacketBufferSize) {\n            // Sent initial handshake, waiting for response.\n            if (this.state === constants_1.SocksClientState.SentInitialHandshake) {\n                if (this._options.proxy.type === 4) {\n                    // Socks v4 only has one handshake response.\n                    this.handleSocks4FinalHandshakeResponse();\n                }\n                else {\n                    // Socks v5 has two handshakes, handle initial one here.\n                    this.handleInitialSocks5HandshakeResponse();\n                }\n                // Sent auth request for Socks v5, waiting for response.\n            }\n            else if (this.state === constants_1.SocksClientState.SentAuthentication) {\n                this.handleInitialSocks5AuthenticationHandshakeResponse();\n                // Sent final Socks v5 handshake, waiting for final response.\n            }\n            else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {\n                this.handleSocks5FinalHandshakeResponse();\n                // Socks BIND established. Waiting for remote connection via proxy.\n            }\n            else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {\n                if (this._options.proxy.type === 4) {\n                    this.handleSocks4IncomingConnectionResponse();\n                }\n                else {\n                    this.handleSocks5IncomingConnectionResponse();\n                }\n            }\n            else if (this.state === constants_1.SocksClientState.Established) {\n                // do nothing (prevents closing of the socket)\n            }\n            else {\n                this._closeSocket(constants_1.ERRORS.InternalError);\n            }\n        }\n    }\n    /**\n     * Handles Socket close event.\n     * @param had_error\n     */\n    onClose() {\n        this._closeSocket(constants_1.ERRORS.SocketClosed);\n    }\n    /**\n     * Handles Socket error event.\n     * @param err\n     */\n    onError(err) {\n        this._closeSocket(err.message);\n    }\n    /**\n     * Removes internal event listeners on the underlying Socket.\n     */\n    removeInternalSocketHandlers() {\n        // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)\n        this._socket.pause();\n        this._socket.removeListener('data', this._onDataReceived);\n        this._socket.removeListener('close', this._onClose);\n        this._socket.removeListener('error', this._onError);\n        this._socket.removeListener('connect', this.onConnect);\n    }\n    /**\n     * Closes and destroys the underlying Socket. Emits an error event.\n     * @param err { String } An error string to include in error event.\n     */\n    _closeSocket(err) {\n        // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.\n        if (this.state !== constants_1.SocksClientState.Error) {\n            // Set internal state to Error.\n            this.state = constants_1.SocksClientState.Error;\n            // Destroy Socket\n            this._socket.destroy();\n            // Remove internal listeners\n            this.removeInternalSocketHandlers();\n            // Fire 'error' event.\n            this.emit('error', new util_1.SocksClientError(err, this._options));\n        }\n    }\n    /**\n     * Sends initial Socks v4 handshake request.\n     */\n    sendSocks4InitialHandshake() {\n        const userId = this._options.proxy.userId || '';\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x04);\n        buff.writeUInt8(constants_1.SocksCommand[this._options.command]);\n        buff.writeUInt16BE(this._options.destination.port);\n        // Socks 4 (IPv4)\n        if (net.isIPv4(this._options.destination.host)) {\n            buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n            buff.writeStringNT(userId);\n            // Socks 4a (hostname)\n        }\n        else {\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x01);\n            buff.writeStringNT(userId);\n            buff.writeStringNT(this._options.destination.host);\n        }\n        this._nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;\n        this._socket.write(buff.toBuffer());\n    }\n    /**\n     * Handles Socks v4 handshake response.\n     * @param data\n     */\n    handleSocks4FinalHandshakeResponse() {\n        const data = this._receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this._closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        }\n        else {\n            // Bind response\n            if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.bind) {\n                const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n                buff.readOffset = 2;\n                const remoteHost = {\n                    port: buff.readUInt16BE(),\n                    host: ip.fromLong(buff.readUInt32BE())\n                };\n                // If host is 0.0.0.0, set to proxy host.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this._options.proxy.ipaddress;\n                }\n                this.state = constants_1.SocksClientState.BoundWaitingForConnection;\n                this.emit('bound', { socket: this._socket, remoteHost });\n                // Connect response\n            }\n            else {\n                this.state = constants_1.SocksClientState.Established;\n                this.removeInternalSocketHandlers();\n                this.emit('established', { socket: this._socket });\n            }\n        }\n    }\n    /**\n     * Handles Socks v4 incoming connection request (BIND)\n     * @param data\n     */\n    handleSocks4IncomingConnectionResponse() {\n        const data = this._receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this._closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        }\n        else {\n            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n            buff.readOffset = 2;\n            const remoteHost = {\n                port: buff.readUInt16BE(),\n                host: ip.fromLong(buff.readUInt32BE())\n            };\n            this.state = constants_1.SocksClientState.Established;\n            this.removeInternalSocketHandlers();\n            this.emit('established', { socket: this._socket, remoteHost });\n        }\n    }\n    /**\n     * Sends initial Socks v5 handshake request.\n     */\n    sendSocks5InitialHandshake() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x05);\n        // We should only tell the proxy we support user/pass auth if auth info is actually provided.\n        // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.\n        if (this._options.proxy.userId || this._options.proxy.password) {\n            buff.writeUInt8(2);\n            buff.writeUInt8(constants_1.Socks5Auth.NoAuth);\n            buff.writeUInt8(constants_1.Socks5Auth.UserPass);\n        }\n        else {\n            buff.writeUInt8(1);\n            buff.writeUInt8(constants_1.Socks5Auth.NoAuth);\n        }\n        this._nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;\n        this._socket.write(buff.toBuffer());\n        this.state = constants_1.SocksClientState.SentInitialHandshake;\n    }\n    /**\n     * Handles initial Socks v5 handshake response.\n     * @param data\n     */\n    handleInitialSocks5HandshakeResponse() {\n        const data = this._receiveBuffer.get(2);\n        if (data[0] !== 0x05) {\n            this._closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);\n        }\n        else if (data[1] === 0xff) {\n            this._closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);\n        }\n        else {\n            // If selected Socks v5 auth method is no auth, send final handshake request.\n            if (data[1] === constants_1.Socks5Auth.NoAuth) {\n                this.sendSocks5CommandRequest();\n                // If selected Socks v5 auth method is user/password, send auth handshake.\n            }\n            else if (data[1] === constants_1.Socks5Auth.UserPass) {\n                this.sendSocks5UserPassAuthentication();\n            }\n            else {\n                this._closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);\n            }\n        }\n    }\n    /**\n     * Sends Socks v5 user & password auth handshake.\n     *\n     * Note: No auth and user/pass are currently supported.\n     */\n    sendSocks5UserPassAuthentication() {\n        const userId = this._options.proxy.userId || '';\n        const password = this._options.proxy.password || '';\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x01);\n        buff.writeUInt8(Buffer.byteLength(userId));\n        buff.writeString(userId);\n        buff.writeUInt8(Buffer.byteLength(password));\n        buff.writeString(password);\n        this._nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;\n        this._socket.write(buff.toBuffer());\n        this.state = constants_1.SocksClientState.SentAuthentication;\n    }\n    /**\n     * Handles Socks v5 auth handshake response.\n     * @param data\n     */\n    handleInitialSocks5AuthenticationHandshakeResponse() {\n        this.state = constants_1.SocksClientState.ReceivedAuthenticationResponse;\n        const data = this._receiveBuffer.get(2);\n        if (data[1] !== 0x00) {\n            this._closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);\n        }\n        else {\n            this.sendSocks5CommandRequest();\n        }\n    }\n    /**\n     * Sends Socks v5 final handshake request.\n     */\n    sendSocks5CommandRequest() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x05);\n        buff.writeUInt8(constants_1.SocksCommand[this._options.command]);\n        buff.writeUInt8(0x00);\n        // ipv4, ipv6, domain?\n        if (net.isIPv4(this._options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n        }\n        else if (net.isIPv6(this._options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer(ip.toBuffer(this._options.destination.host));\n        }\n        else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(this._options.destination.host.length);\n            buff.writeString(this._options.destination.host);\n        }\n        buff.writeUInt16BE(this._options.destination.port);\n        this._nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n        this._socket.write(buff.toBuffer());\n        this.state = constants_1.SocksClientState.SentFinalHandshake;\n    }\n    /**\n     * Handles Socks v5 final handshake response.\n     * @param data\n     */\n    handleSocks5FinalHandshakeResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this._receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this._closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);\n        }\n        else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip.fromLong(buff.readUInt32BE()),\n                    port: buff.readUInt16BE()\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this._options.proxy.ipaddress;\n                }\n                // Hostname\n            }\n            else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port\n                // Check if data is available.\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(5) // Slice at 5 to skip host length\n                );\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE()\n                };\n                // IPv6\n            }\n            else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip.toString(buff.readBuffer(16)),\n                    port: buff.readUInt16BE()\n                };\n            }\n            // We have everything we need\n            this.state = constants_1.SocksClientState.ReceivedFinalResponse;\n            // If using CONNECT, the client is now in the established state.\n            if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.connect) {\n                this.state = constants_1.SocksClientState.Established;\n                this.removeInternalSocketHandlers();\n                this.emit('established', { socket: this._socket });\n            }\n            else if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.bind) {\n                /* If using BIND, the Socks client is now in BoundWaitingForConnection state.\n                   This means that the remote proxy server is waiting for a remote connection to the bound port. */\n                this.state = constants_1.SocksClientState.BoundWaitingForConnection;\n                this._nextRequiredPacketBufferSize =\n                    constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n                this.emit('bound', { socket: this._socket, remoteHost });\n                /*\n                  If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the\n                  given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.\n                */\n            }\n            else if (constants_1.SocksCommand[this._options.command] === constants_1.SocksCommand.associate) {\n                this.state = constants_1.SocksClientState.Established;\n                this.removeInternalSocketHandlers();\n                this.emit('established', { socket: this._socket, remoteHost });\n            }\n        }\n    }\n    /**\n     * Handles Socks v5 incoming connection request (BIND).\n     */\n    handleSocks5IncomingConnectionResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this._receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this._closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);\n        }\n        else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip.fromLong(buff.readUInt32BE()),\n                    port: buff.readUInt16BE()\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this._options.proxy.ipaddress;\n                }\n                // Hostname\n            }\n            else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port\n                // Check if data is available.\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(5) // Slice at 5 to skip host length\n                );\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE()\n                };\n                // IPv6\n            }\n            else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this._receiveBuffer.length < dataNeeded) {\n                    this._nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this._receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip.toString(buff.readBuffer(16)),\n                    port: buff.readUInt16BE()\n                };\n            }\n            this.state = constants_1.SocksClientState.Established;\n            this.removeInternalSocketHandlers();\n            this.emit('established', { socket: this._socket, remoteHost });\n        }\n    }\n    get socksClientOptions() {\n        return Object.assign({}, this._options);\n    }\n}\nexports.SocksClient = SocksClient;\n//# sourceMappingURL=socksclient.js.map"]},"metadata":{},"sourceType":"script"}