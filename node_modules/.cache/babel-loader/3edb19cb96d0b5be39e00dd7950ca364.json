{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar url = require('url');\n\nvar assert = require('assert');\n\nvar Agent = require('agent-base');\n\nvar inherits = require('util').inherits;\n\nvar debug = require('debug')('https-proxy-agent');\n/**\n * Module exports.\n */\n\n\nmodule.exports = HttpsProxyAgent;\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n  debug('creating new HttpsProxyAgent instance: %o', opts);\n  Agent.call(this, opts);\n  var proxy = Object.assign({}, opts); // if `true`, then connect to the proxy server over TLS. defaults to `false`.\n\n  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false; // prefer `hostname` over `host`, and set the `port` if needed\n\n  proxy.host = proxy.hostname || proxy.host;\n  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80); // ALPN is supported by Node.js >= v5.\n  // attempt to negotiate http/1.1 for proxy servers that support http/2\n\n  if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n    proxy.ALPNProtocols = ['http 1.1'];\n  }\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  this.proxy = proxy;\n  this.defaultPort = 443;\n}\n\ninherits(HttpsProxyAgent, Agent);\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy; // create a socket connection to the proxy server\n\n  var socket;\n\n  if (this.secureProxy) {\n    socket = tls.connect(proxy);\n  } else {\n    socket = net.connect(proxy);\n  } // we need to buffer any HTTP traffic that happens with the proxy before we get\n  // the CONNECT response, so that if the response is anything other than an \"200\"\n  // response code, then we can re-play the \"data\" events on the socket once the\n  // HTTP parser is hooked up...\n\n\n  var buffers = [];\n  var buffersLength = 0;\n\n  function read() {\n    var b = socket.read();\n    if (b) ondata(b);else socket.once('readable', read);\n  }\n\n  function cleanup() {\n    socket.removeListener('end', onend);\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    socket.removeListener('readable', read);\n  }\n\n  function onclose(err) {\n    debug('onclose had error %o', err);\n  }\n\n  function onend() {\n    debug('onend');\n  }\n\n  function onerror(err) {\n    cleanup();\n    fn(err);\n  }\n\n  function ondata(b) {\n    buffers.push(b);\n    buffersLength += b.length;\n    var buffered = Buffer.concat(buffers, buffersLength);\n    var str = buffered.toString('ascii');\n\n    if (!~str.indexOf('\\r\\n\\r\\n')) {\n      // keep buffering\n      debug('have not received end of HTTP headers yet...');\n      read();\n      return;\n    }\n\n    var firstLine = str.substring(0, str.indexOf('\\r\\n'));\n    var statusCode = +firstLine.split(' ')[1];\n    debug('got proxy server response: %o', firstLine);\n\n    if (200 == statusCode) {\n      // 200 Connected status code!\n      var sock = socket; // nullify the buffered data since we won't be needing it\n\n      buffers = buffered = null;\n\n      if (opts.secureEndpoint) {\n        // since the proxy is connecting to an SSL server, we have\n        // to upgrade this socket connection to an SSL connection\n        debug('upgrading proxy-connected socket to TLS connection: %o', opts.host);\n        opts.socket = socket;\n        opts.servername = opts.servername || opts.host;\n        opts.host = null;\n        opts.hostname = null;\n        opts.port = null;\n        sock = tls.connect(opts);\n      }\n\n      cleanup();\n      req.once('socket', resume);\n      fn(null, sock);\n    } else {\n      // some other status code that's not 200... need to re-play the HTTP header\n      // \"data\" events onto the socket once the HTTP machinery is attached so\n      // that the node core `http` can parse and handle the error status code\n      cleanup(); // the original socket is closed, and a new closed socket is\n      // returned instead, so that the proxy doesn't get the HTTP request\n      // written to it (which may contain `Authorization` headers or other\n      // sensitive data).\n      //\n      // See: https://hackerone.com/reports/541502\n\n      socket.destroy();\n      socket = new net.Socket();\n      socket.readable = true; // save a reference to the concat'd Buffer for the `onsocket` callback\n\n      buffers = buffered; // need to wait for the \"socket\" event to re-play the \"data\" events\n\n      req.once('socket', onsocket);\n      fn(null, socket);\n    }\n  }\n\n  function onsocket(socket) {\n    debug('replaying proxy buffer for failed request');\n    assert(socket.listenerCount('data') > 0); // replay the \"buffers\" Buffer onto the `socket`, since at this point\n    // the HTTP module machinery has been hooked up for the user\n\n    socket.push(buffers); // nullify the cached Buffer instance\n\n    buffers = null;\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('end', onend);\n  read();\n  var hostname = opts.host + ':' + opts.port;\n  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n  var headers = Object.assign({}, proxy.headers);\n\n  if (proxy.auth) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n  } // the Host header should only include the port\n  // number when it is a non-standard port\n\n\n  var host = opts.host;\n\n  if (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n    host += ':' + opts.port;\n  }\n\n  headers['Host'] = host;\n  headers['Connection'] = 'close';\n  Object.keys(headers).forEach(function (name) {\n    msg += name + ': ' + headers[name] + '\\r\\n';\n  });\n  socket.write(msg + '\\r\\n');\n};\n/**\n * Resumes a socket.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket to resume\n * @api public\n */\n\n\nfunction resume(socket) {\n  socket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/https-proxy-agent/index.js"],"names":["net","require","tls","url","assert","Agent","inherits","debug","module","exports","HttpsProxyAgent","opts","parse","Error","call","proxy","Object","assign","secureProxy","protocol","test","host","hostname","port","ALPNProtocols","path","pathname","defaultPort","prototype","callback","connect","req","fn","socket","buffers","buffersLength","read","b","ondata","once","cleanup","removeListener","onend","onerror","onclose","err","push","length","buffered","Buffer","concat","str","toString","indexOf","firstLine","substring","statusCode","split","sock","secureEndpoint","servername","resume","destroy","Socket","readable","onsocket","listenerCount","on","msg","headers","auth","from","isDefaultPort","keys","forEach","name","write","secure","Boolean"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar tls = require('tls');\nvar url = require('url');\nvar assert = require('assert');\nvar Agent = require('agent-base');\nvar inherits = require('util').inherits;\nvar debug = require('debug')('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n\tif (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n\tif ('string' == typeof opts) opts = url.parse(opts);\n\tif (!opts)\n\t\tthrow new Error(\n\t\t\t'an HTTP(S) proxy server `host` and `port` must be specified!'\n\t\t);\n\tdebug('creating new HttpsProxyAgent instance: %o', opts);\n\tAgent.call(this, opts);\n\n\tvar proxy = Object.assign({}, opts);\n\n\t// if `true`, then connect to the proxy server over TLS. defaults to `false`.\n\tthis.secureProxy = proxy.protocol\n\t\t? /^https:?$/i.test(proxy.protocol)\n\t\t: false;\n\n\t// prefer `hostname` over `host`, and set the `port` if needed\n\tproxy.host = proxy.hostname || proxy.host;\n\tproxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n\t// ALPN is supported by Node.js >= v5.\n\t// attempt to negotiate http/1.1 for proxy servers that support http/2\n\tif (this.secureProxy && !('ALPNProtocols' in proxy)) {\n\t\tproxy.ALPNProtocols = ['http 1.1'];\n\t}\n\n\tif (proxy.host && proxy.path) {\n\t\t// if both a `host` and `path` are specified then it's most likely the\n\t\t// result of a `url.parse()` call... we need to remove the `path` portion so\n\t\t// that `net.connect()` doesn't attempt to open that as a unix socket file.\n\t\tdelete proxy.path;\n\t\tdelete proxy.pathname;\n\t}\n\n\tthis.proxy = proxy;\n\tthis.defaultPort = 443;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n\tvar proxy = this.proxy;\n\n\t// create a socket connection to the proxy server\n\tvar socket;\n\tif (this.secureProxy) {\n\t\tsocket = tls.connect(proxy);\n\t} else {\n\t\tsocket = net.connect(proxy);\n\t}\n\n\t// we need to buffer any HTTP traffic that happens with the proxy before we get\n\t// the CONNECT response, so that if the response is anything other than an \"200\"\n\t// response code, then we can re-play the \"data\" events on the socket once the\n\t// HTTP parser is hooked up...\n\tvar buffers = [];\n\tvar buffersLength = 0;\n\n\tfunction read() {\n\t\tvar b = socket.read();\n\t\tif (b) ondata(b);\n\t\telse socket.once('readable', read);\n\t}\n\n\tfunction cleanup() {\n\t\tsocket.removeListener('end', onend);\n\t\tsocket.removeListener('error', onerror);\n\t\tsocket.removeListener('close', onclose);\n\t\tsocket.removeListener('readable', read);\n\t}\n\n\tfunction onclose(err) {\n\t\tdebug('onclose had error %o', err);\n\t}\n\n\tfunction onend() {\n\t\tdebug('onend');\n\t}\n\n\tfunction onerror(err) {\n\t\tcleanup();\n\t\tfn(err);\n\t}\n\n\tfunction ondata(b) {\n\t\tbuffers.push(b);\n\t\tbuffersLength += b.length;\n\t\tvar buffered = Buffer.concat(buffers, buffersLength);\n\t\tvar str = buffered.toString('ascii');\n\n\t\tif (!~str.indexOf('\\r\\n\\r\\n')) {\n\t\t\t// keep buffering\n\t\t\tdebug('have not received end of HTTP headers yet...');\n\t\t\tread();\n\t\t\treturn;\n\t\t}\n\n\t\tvar firstLine = str.substring(0, str.indexOf('\\r\\n'));\n\t\tvar statusCode = +firstLine.split(' ')[1];\n\t\tdebug('got proxy server response: %o', firstLine);\n\n\t\tif (200 == statusCode) {\n\t\t\t// 200 Connected status code!\n\t\t\tvar sock = socket;\n\n\t\t\t// nullify the buffered data since we won't be needing it\n\t\t\tbuffers = buffered = null;\n\n\t\t\tif (opts.secureEndpoint) {\n\t\t\t\t// since the proxy is connecting to an SSL server, we have\n\t\t\t\t// to upgrade this socket connection to an SSL connection\n\t\t\t\tdebug(\n\t\t\t\t\t'upgrading proxy-connected socket to TLS connection: %o',\n\t\t\t\t\topts.host\n\t\t\t\t);\n\t\t\t\topts.socket = socket;\n\t\t\t\topts.servername = opts.servername || opts.host;\n\t\t\t\topts.host = null;\n\t\t\t\topts.hostname = null;\n\t\t\t\topts.port = null;\n\t\t\t\tsock = tls.connect(opts);\n\t\t\t}\n\n\t\t\tcleanup();\n\t\t\treq.once('socket', resume);\n\t\t\tfn(null, sock);\n\t\t} else {\n\t\t\t// some other status code that's not 200... need to re-play the HTTP header\n\t\t\t// \"data\" events onto the socket once the HTTP machinery is attached so\n\t\t\t// that the node core `http` can parse and handle the error status code\n\t\t\tcleanup();\n\n\t\t\t// the original socket is closed, and a new closed socket is\n\t\t\t// returned instead, so that the proxy doesn't get the HTTP request\n\t\t\t// written to it (which may contain `Authorization` headers or other\n\t\t\t// sensitive data).\n\t\t\t//\n\t\t\t// See: https://hackerone.com/reports/541502\n\t\t\tsocket.destroy();\n\t\t\tsocket = new net.Socket();\n\t\t\tsocket.readable = true;\n\n\n\t\t\t// save a reference to the concat'd Buffer for the `onsocket` callback\n\t\t\tbuffers = buffered;\n\n\t\t\t// need to wait for the \"socket\" event to re-play the \"data\" events\n\t\t\treq.once('socket', onsocket);\n\n\t\t\tfn(null, socket);\n\t\t}\n\t}\n\n\tfunction onsocket(socket) {\n\t\tdebug('replaying proxy buffer for failed request');\n\t\tassert(socket.listenerCount('data') > 0);\n\n\t\t// replay the \"buffers\" Buffer onto the `socket`, since at this point\n\t\t// the HTTP module machinery has been hooked up for the user\n\t\tsocket.push(buffers);\n\n\t\t// nullify the cached Buffer instance\n\t\tbuffers = null;\n\t}\n\n\tsocket.on('error', onerror);\n\tsocket.on('close', onclose);\n\tsocket.on('end', onend);\n\n\tread();\n\n\tvar hostname = opts.host + ':' + opts.port;\n\tvar msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n\n\tvar headers = Object.assign({}, proxy.headers);\n\tif (proxy.auth) {\n\t\theaders['Proxy-Authorization'] =\n\t\t\t'Basic ' + Buffer.from(proxy.auth).toString('base64');\n\t}\n\n\t// the Host header should only include the port\n\t// number when it is a non-standard port\n\tvar host = opts.host;\n\tif (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n\t\thost += ':' + opts.port;\n\t}\n\theaders['Host'] = host;\n\n\theaders['Connection'] = 'close';\n\tObject.keys(headers).forEach(function(name) {\n\t\tmsg += name + ': ' + headers[name] + '\\r\\n';\n\t});\n\n\tsocket.write(msg + '\\r\\n');\n};\n\n/**\n * Resumes a socket.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket to resume\n * @api public\n */\n\nfunction resume(socket) {\n\tsocket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n\treturn Boolean((!secure && port === 80) || (secure && port === 443));\n}\n"]},"metadata":{},"sourceType":"script"}