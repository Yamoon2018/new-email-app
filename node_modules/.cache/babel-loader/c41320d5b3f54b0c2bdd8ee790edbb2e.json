{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar url = require('url');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar extend = require('extend');\n\nvar NotFoundError = require('./notfound');\n\nvar NotModifiedError = require('./notmodified');\n\nvar debug = require('debug')('get-uri:http');\n/**\n * Module exports.\n */\n\n\nmodule.exports = get;\n/**\n * Returns a Readable stream from an \"http:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  debug('GET %o', parsed.href);\n  var cache = getCache(parsed, opts.cache); // 5 redirects allowed by default\n\n  var maxRedirects = opts.hasOwnProperty('maxRedirects') ? opts.maxRedirects : 5;\n  debug('allowing %o max redirects', maxRedirects); // first check the previous Expires and/or Cache-Control headers\n  // of a previous response if a `cache` was provided\n\n  if (cache && isFresh(cache)) {\n    // check for a 3xx \"redirect\" status code on the previous cache\n    var location = cache.headers.location;\n    var type = cache.statusCode / 100 | 0;\n\n    if (3 == type && location) {\n      debug('cached redirect');\n      fn(new Error('TODO: implement cached redirects!'));\n    } else {\n      // otherwise we assume that it's the destination endpoint,\n      // since there's nowhere else to redirect to\n      fn(new NotModifiedError());\n    }\n\n    return;\n  }\n\n  var mod;\n\n  if (opts.http) {\n    // the `https` module passed in from the \"http.js\" file\n    mod = opts.http;\n    debug('using secure `https` core module');\n  } else {\n    mod = http;\n    debug('using `http` core module');\n  }\n\n  var options = extend({}, opts, parsed); // add \"cache validation\" headers if a `cache` was provided\n\n  if (cache) {\n    if (!options.headers) options.headers = {};\n    var lastModified = cache.headers['last-modified'];\n\n    if (lastModified != null) {\n      options.headers['If-Modified-Since'] = lastModified;\n      debug('added \"If-Modified-Since\" request header: %o', lastModified);\n    }\n\n    var etag = cache.headers.etag;\n\n    if (etag != null) {\n      options.headers['If-None-Match'] = etag;\n      debug('added \"If-None-Match\" request header: %o', etag);\n    }\n  }\n\n  var req = mod.get(options);\n  req.once('error', onerror);\n  req.once('response', onresponse); // http.ClientRequest \"error\" event handler\n\n  function onerror(err) {\n    debug('http.ClientRequest \"error\" event: %o', err.stack || err);\n    fn(err);\n  } // http.ClientRequest \"response\" event handler\n\n\n  function onresponse(res) {\n    var code = res.statusCode; // assign a Date to this response for the \"Cache-Control\" delta calculation\n\n    res.date = new Date();\n    res.parsed = parsed;\n    debug('got %o response status code', code); // any 2xx response is a \"success\" code\n\n    var type = code / 100 | 0; // check for a 3xx \"redirect\" status code\n\n    var location = res.headers.location;\n\n    if (3 == type && location) {\n      if (!opts.redirects) opts.redirects = [];\n      var redirects = opts.redirects;\n\n      if (redirects.length < maxRedirects) {\n        debug('got a \"redirect\" status code with Location: %o', location); // flush this response - we're not going to use it\n\n        res.resume(); // hang on to this Response object for the \"redirects\" Array\n\n        redirects.push(res);\n        var newUri = url.resolve(parsed, location);\n        debug('resolved redirect URL: %o', newUri);\n        var left = maxRedirects - redirects.length;\n        debug('%o more redirects allowed after this one', left); // check if redirecting to a different protocol\n\n        var parsedUrl = url.parse(newUri);\n\n        if (parsedUrl.protocol !== parsed.protocol) {\n          opts.http = parsedUrl.protocol === 'https:' ? https : undefined;\n        }\n\n        return get(parsedUrl, opts, fn);\n      }\n    } // if we didn't get a 2xx \"success\" status code, then create an Error object\n\n\n    if (2 != type) {\n      var err;\n\n      if (304 == code) {\n        err = new NotModifiedError();\n      } else if (404 == code) {\n        err = new NotFoundError();\n      } else {\n        // other HTTP-level error\n        var message = http.STATUS_CODES[code];\n        err = new Error(message);\n        err.statusCode = code;\n        err.code = code;\n      }\n\n      res.resume();\n      return fn(err);\n    }\n\n    if (opts.redirects) {\n      // store a reference to the \"redirects\" Array on the Response object so that\n      // they can be inspected during a subsequent call to GET the same URI\n      res.redirects = opts.redirects;\n    }\n\n    fn(null, res);\n  }\n}\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isFresh(cache) {\n  var cacheControl = cache.headers['cache-control'];\n  var expires = cache.headers.expires;\n  var fresh;\n\n  if (cacheControl) {\n    // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n    debug('Cache-Control: %o', cacheControl);\n    var parts = cacheControl.split(/,\\s*?\\b/);\n\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      var subparts = part.split('=');\n      var name = subparts[0];\n\n      switch (name) {\n        case 'max-age':\n          var val = +subparts[1];\n          expires = new Date(+cache.date + val * 1000);\n          fresh = new Date() < expires;\n          if (fresh) debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n          return fresh;\n\n        case 'must-revalidate':\n          // XXX: what we supposed to do here?\n          break;\n\n        case 'no-cache':\n        case 'no-store':\n          debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n          return false;\n      }\n    }\n  } else if (expires) {\n    // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n    debug('Expires: %o', expires);\n    fresh = new Date() < new Date(expires);\n    if (fresh) debug('cache is \"fresh\" due to previous Expires response header');\n    return fresh;\n  }\n\n  return false;\n}\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\n\n\nfunction getCache(parsed, cache) {\n  if (!cache) return;\n  var href = parsed.href;\n\n  if (cache.parsed.href == href) {\n    return cache;\n  }\n\n  var redirects = cache.redirects;\n\n  if (redirects) {\n    for (var i = 0; i < redirects.length; i++) {\n      var c = getCache(parsed, redirects[i]);\n      if (c) return c;\n    }\n  }\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/get-uri/http.js"],"names":["url","require","http","https","extend","NotFoundError","NotModifiedError","debug","module","exports","get","parsed","opts","fn","href","cache","getCache","maxRedirects","hasOwnProperty","isFresh","location","headers","type","statusCode","Error","mod","options","lastModified","etag","req","once","onerror","onresponse","err","stack","res","code","date","Date","redirects","length","resume","push","newUri","resolve","left","parsedUrl","parse","protocol","undefined","message","STATUS_CODES","cacheControl","expires","fresh","parts","split","i","part","subparts","name","val","c"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar url = require('url');\nvar http = require('http');\nvar https = require('https');\nvar extend = require('extend');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:http');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a Readable stream from an \"http:\" URI.\n *\n * @api protected\n */\n\nfunction get (parsed, opts, fn) {\n  debug('GET %o', parsed.href);\n\n  var cache = getCache(parsed, opts.cache);\n\n  // 5 redirects allowed by default\n  var maxRedirects = opts.hasOwnProperty('maxRedirects') ? opts.maxRedirects : 5;\n  debug('allowing %o max redirects', maxRedirects);\n\n  // first check the previous Expires and/or Cache-Control headers\n  // of a previous response if a `cache` was provided\n  if (cache && isFresh(cache)) {\n\n    // check for a 3xx \"redirect\" status code on the previous cache\n    var location = cache.headers.location;\n    var type = (cache.statusCode / 100 | 0);\n    if (3 == type && location) {\n      debug('cached redirect');\n      fn(new Error('TODO: implement cached redirects!'));\n    } else {\n      // otherwise we assume that it's the destination endpoint,\n      // since there's nowhere else to redirect to\n      fn(new NotModifiedError());\n    }\n    return;\n  }\n\n  var mod;\n  if (opts.http) {\n    // the `https` module passed in from the \"http.js\" file\n    mod = opts.http;\n    debug('using secure `https` core module');\n  } else {\n    mod = http;\n    debug('using `http` core module');\n  }\n\n  var options = extend({}, opts, parsed);\n\n  // add \"cache validation\" headers if a `cache` was provided\n  if (cache) {\n    if (!options.headers) options.headers = {};\n\n    var lastModified = cache.headers['last-modified'];\n    if (lastModified != null) {\n      options.headers['If-Modified-Since'] = lastModified;\n      debug('added \"If-Modified-Since\" request header: %o', lastModified);\n    }\n\n    var etag = cache.headers.etag;\n    if (etag != null) {\n      options.headers['If-None-Match'] = etag;\n      debug('added \"If-None-Match\" request header: %o', etag);\n    }\n  }\n\n  var req = mod.get(options);\n  req.once('error', onerror);\n  req.once('response', onresponse);\n\n  // http.ClientRequest \"error\" event handler\n  function onerror (err) {\n    debug('http.ClientRequest \"error\" event: %o', err.stack || err);\n    fn(err);\n  }\n\n  // http.ClientRequest \"response\" event handler\n  function onresponse (res) {\n    var code = res.statusCode;\n\n    // assign a Date to this response for the \"Cache-Control\" delta calculation\n    res.date = new Date();\n    res.parsed = parsed;\n\n    debug('got %o response status code', code);\n\n    // any 2xx response is a \"success\" code\n    var type = (code / 100 | 0);\n\n    // check for a 3xx \"redirect\" status code\n    var location = res.headers.location;\n    if (3 == type && location) {\n      if (!opts.redirects) opts.redirects = [];\n      var redirects = opts.redirects;\n\n      if (redirects.length < maxRedirects) {\n        debug('got a \"redirect\" status code with Location: %o', location);\n\n        // flush this response - we're not going to use it\n        res.resume();\n\n        // hang on to this Response object for the \"redirects\" Array\n        redirects.push(res);\n\n        var newUri = url.resolve(parsed, location);\n        debug('resolved redirect URL: %o', newUri);\n\n        var left = maxRedirects - redirects.length;\n        debug('%o more redirects allowed after this one', left);\n\n        // check if redirecting to a different protocol\n        var parsedUrl = url.parse(newUri);\n        if (parsedUrl.protocol !== parsed.protocol) {\n          opts.http = parsedUrl.protocol === 'https:' ? https : undefined;\n        }\n\n        return get(parsedUrl, opts, fn);\n      }\n    }\n\n    // if we didn't get a 2xx \"success\" status code, then create an Error object\n    if (2 != type) {\n      var err;\n      if (304 == code) {\n        err = new NotModifiedError();\n      } else if (404 == code) {\n        err = new NotFoundError();\n      } else {\n        // other HTTP-level error\n        var message = http.STATUS_CODES[code];\n        err = new Error(message);\n        err.statusCode = code;\n        err.code = code;\n      }\n\n      res.resume();\n      return fn(err);\n    }\n\n    if (opts.redirects) {\n      // store a reference to the \"redirects\" Array on the Response object so that\n      // they can be inspected during a subsequent call to GET the same URI\n      res.redirects = opts.redirects;\n    }\n\n    fn(null, res);\n  }\n}\n\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\n\nfunction isFresh (cache) {\n  var cacheControl = cache.headers['cache-control'];\n  var expires = cache.headers.expires;\n  var fresh;\n\n  if (cacheControl) {\n    // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n    debug('Cache-Control: %o', cacheControl);\n\n    var parts = cacheControl.split(/,\\s*?\\b/);\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      var subparts = part.split('=');\n      var name = subparts[0];\n      switch (name) {\n        case 'max-age':\n          var val = +subparts[1];\n          expires = new Date(+cache.date + (val * 1000));\n          fresh = new Date() < expires;\n          if (fresh) debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n          return fresh;\n        case 'must-revalidate':\n          // XXX: what we supposed to do here?\n          break;\n        case 'no-cache':\n        case 'no-store':\n          debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n          return false;\n      }\n    }\n\n  } else if (expires) {\n    // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n    debug('Expires: %o', expires);\n\n    fresh = new Date() < new Date(expires);\n    if (fresh) debug('cache is \"fresh\" due to previous Expires response header');\n    return fresh;\n  }\n\n  return false;\n}\n\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\n\nfunction getCache (parsed, cache) {\n  if (!cache) return;\n  var href = parsed.href;\n  if (cache.parsed.href == href) {\n    return cache;\n  }\n  var redirects = cache.redirects;\n  if (redirects) {\n    for (var i = 0; i < redirects.length; i++) {\n      var c = getCache(parsed, redirects[i]);\n      if (c) return c;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}