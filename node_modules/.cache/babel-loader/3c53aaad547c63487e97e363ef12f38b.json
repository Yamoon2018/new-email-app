{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar fs = require('fs');\n\nvar uri2path = require('file-uri-to-path');\n\nvar NotFoundError = require('./notfound');\n\nvar NotModifiedError = require('./notmodified');\n\nvar debug = require('debug')('get-uri:file');\n/**\n * Module exports.\n */\n\n\nmodule.exports = get;\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  var fd;\n  var cache = opts.cache; // same as in fs.ReadStream's constructor\n\n  var flags = opts.hasOwnProperty('flags') ? options.flags : 'r';\n  var mode = opts.hasOwnProperty('mode') ? options.mode : 438;\n  /*=0666*/\n  // convert URI → Path\n\n  var uri = parsed.href;\n  var filepath = uri2path(uri);\n  debug('normalized pathname: %o', filepath); // open() first to get a fd and ensure that the file exists\n\n  fs.open(filepath, flags, mode, onopen);\n\n  function onerror(err) {\n    if ('number' == typeof fd) {\n      fs.close(fd, onclose);\n    }\n\n    fn(err);\n  }\n\n  function onclose() {\n    debug('closed fd %o', fd);\n  }\n\n  function onopen(err, _fd) {\n    if (err) {\n      if ('ENOENT' == err.code) {\n        err = new NotFoundError();\n      }\n\n      return onerror(err);\n    }\n\n    fd = _fd; // now fstat() to check the `mtime` and store the stat object for the cache\n\n    fs.fstat(fd, onstat);\n  }\n\n  function onstat(err, stat) {\n    if (err) return onerror(err); // if a `cache` was provided, check if the file has not been modified\n\n    if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n      return onerror(new NotModifiedError());\n    } // `fs.ReadStream` takes care of calling `fs.close()` on the\n    // fd after it's done reading\n\n\n    opts.fd = fd;\n    var rs = fs.createReadStream(null, opts);\n    rs.stat = stat;\n    fn(null, rs);\n  } // returns `true` if the `mtime` of the 2 stat objects are equal\n\n\n  function isNotModified(prev, curr) {\n    return +prev.mtime == +curr.mtime;\n  }\n}","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/get-uri/file.js"],"names":["fs","require","uri2path","NotFoundError","NotModifiedError","debug","module","exports","get","parsed","opts","fn","fd","cache","flags","hasOwnProperty","options","mode","uri","href","filepath","open","onopen","onerror","err","close","onclose","_fd","code","fstat","onstat","stat","isNotModified","rs","createReadStream","prev","curr","mtime"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs');\nvar uri2path = require('file-uri-to-path');\nvar NotFoundError = require('./notfound');\nvar NotModifiedError = require('./notmodified');\nvar debug = require('debug')('get-uri:file');\n\n/**\n * Module exports.\n */\n\nmodule.exports = get;\n\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n *\n * @api protected\n */\n\nfunction get (parsed, opts, fn) {\n\n  var fd;\n  var cache = opts.cache;\n\n  // same as in fs.ReadStream's constructor\n  var flags = opts.hasOwnProperty('flags') ? options.flags : 'r';\n  var mode = opts.hasOwnProperty('mode') ? options.mode : 438; /*=0666*/\n\n  // convert URI → Path\n  var uri = parsed.href;\n  var filepath = uri2path(uri);\n  debug('normalized pathname: %o', filepath);\n\n  // open() first to get a fd and ensure that the file exists\n  fs.open(filepath, flags, mode, onopen);\n\n  function onerror (err) {\n    if ('number' == typeof fd) {\n      fs.close(fd, onclose);\n    }\n    fn(err);\n  }\n\n  function onclose () {\n    debug('closed fd %o', fd);\n  }\n\n  function onopen (err, _fd) {\n    if (err) {\n      if ('ENOENT' == err.code) {\n        err = new NotFoundError();\n      }\n      return onerror(err);\n    }\n    fd = _fd;\n\n    // now fstat() to check the `mtime` and store the stat object for the cache\n    fs.fstat(fd, onstat);\n  }\n\n  function onstat (err, stat) {\n    if (err) return onerror(err);\n\n    // if a `cache` was provided, check if the file has not been modified\n    if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n      return onerror(new NotModifiedError());\n    }\n\n    // `fs.ReadStream` takes care of calling `fs.close()` on the\n    // fd after it's done reading\n    opts.fd = fd;\n    var rs = fs.createReadStream(null, opts);\n    rs.stat = stat;\n\n    fn(null, rs);\n  }\n\n  // returns `true` if the `mtime` of the 2 stat objects are equal\n  function isNotModified (prev, curr) {\n    return +prev.mtime == +curr.mtime;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}