{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/yamin/My_repos/new-email-app/new-email-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\n\n\nvar MessageParser = /*#__PURE__*/function (_Transform) {\n  _inherits(MessageParser, _Transform);\n\n  var _super = _createSuper(MessageParser);\n\n  function MessageParser(options) {\n    var _this;\n\n    _classCallCheck(this, MessageParser);\n\n    _this = _super.call(this, options);\n    _this.lastBytes = Buffer.alloc(4);\n    _this.headersParsed = false;\n    _this.headerBytes = 0;\n    _this.headerChunks = [];\n    _this.rawHeaders = false;\n    _this.bodySize = 0;\n    return _this;\n  }\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n\n\n  _createClass(MessageParser, [{\n    key: \"updateLastBytes\",\n    value: function updateLastBytes(data) {\n      var lblen = this.lastBytes.length;\n      var nblen = Math.min(data.length, lblen); // shift existing bytes\n\n      for (var i = 0, len = lblen - nblen; i < len; i++) {\n        this.lastBytes[i] = this.lastBytes[i + nblen];\n      } // add new bytes\n\n\n      for (var _i = 1; _i <= nblen; _i++) {\n        this.lastBytes[lblen - _i] = data[data.length - _i];\n      }\n    }\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n\n  }, {\n    key: \"checkHeaders\",\n    value: function checkHeaders(data) {\n      var _this2 = this;\n\n      if (this.headersParsed) {\n        return true;\n      }\n\n      var lblen = this.lastBytes.length;\n      var headerPos = 0;\n      this.curLinePos = 0;\n\n      for (var i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n        var chr = void 0;\n\n        if (i < lblen) {\n          chr = this.lastBytes[i];\n        } else {\n          chr = data[i - lblen];\n        }\n\n        if (chr === 0x0a && i) {\n          var pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n          var pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n\n          if (pr1 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          } else if (pr1 === 0x0d && pr2 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          }\n        }\n      }\n\n      if (this.headersParsed) {\n        this.headerChunks.push(data.slice(0, headerPos));\n        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.headerChunks = null;\n        this.emit('headers', this.parseHeaders());\n\n        if (data.length - 1 > headerPos) {\n          var chunk = data.slice(headerPos);\n          this.bodySize += chunk.length; // this would be the first chunk of data sent downstream\n\n          setImmediate(function () {\n            return _this2.push(chunk);\n          });\n        }\n\n        return false;\n      } else {\n        this.headerBytes += data.length;\n        this.headerChunks.push(data);\n      } // store last 4 bytes to catch header break\n\n\n      this.updateLastBytes(data);\n      return false;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (!chunk || !chunk.length) {\n        return callback();\n      }\n\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      var headersFound;\n\n      try {\n        headersFound = this.checkHeaders(chunk);\n      } catch (E) {\n        return callback(E);\n      }\n\n      if (headersFound) {\n        this.bodySize += chunk.length;\n        this.push(chunk);\n      }\n\n      setImmediate(callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.headerChunks) {\n        var chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.bodySize += chunk.length;\n        this.push(chunk);\n        this.headerChunks = null;\n      }\n\n      callback();\n    }\n  }, {\n    key: \"parseHeaders\",\n    value: function parseHeaders() {\n      var lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n\n      for (var i = lines.length - 1; i > 0; i--) {\n        if (/^\\s/.test(lines[i])) {\n          lines[i - 1] += '\\n' + lines[i];\n          lines.splice(i, 1);\n        }\n      }\n\n      return lines.filter(function (line) {\n        return line.trim();\n      }).map(function (line) {\n        return {\n          key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n          line: line\n        };\n      });\n    }\n  }]);\n\n  return MessageParser;\n}(Transform);\n\nmodule.exports = MessageParser;","map":{"version":3,"sources":["/home/yamin/My_repos/new-email-app/new-email-app/node_modules/nodemailer/lib/dkim/message-parser.js"],"names":["Transform","require","MessageParser","options","lastBytes","Buffer","alloc","headersParsed","headerBytes","headerChunks","rawHeaders","bodySize","data","lblen","length","nblen","Math","min","i","len","headerPos","curLinePos","chr","pr1","pr2","push","slice","concat","emit","parseHeaders","chunk","setImmediate","updateLastBytes","encoding","callback","from","headersFound","checkHeaders","E","lines","toString","split","test","splice","filter","line","trim","map","key","substr","indexOf","toLowerCase","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n"]},"metadata":{},"sourceType":"script"}